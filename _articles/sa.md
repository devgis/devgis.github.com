---
layout: post
title: 软件系统架构
description: 关于计算机软件系统架构研究学习资料
date: 2022-10-01 09:01:01
updatedate: 2024-03-26 10:59:46
---
- [软件架构模式的演进](#软件架构模式的演进)
- [开发模式](#开发模式)
  - [ATDD：验收测试驱动开发](#atdd验收测试驱动开发)
      - [什么是ATDD#](#什么是atdd)
      - [ATDD工具](#atdd工具)
        - [Selenium](#selenium)
        - [Robot Framework](#robot-framework)
      - [ATDD的基本流程#](#atdd的基本流程)
        - [讨论澄清阶段](#讨论澄清阶段)
        - [开发阶段](#开发阶段)
        - [交付阶段](#交付阶段)
      - [ATDD的好处#](#atdd的好处)
      - [ATDD自动化测试框架](#atdd自动化测试框架)
  - [DDD：领域驱动开发](#ddd领域驱动开发)
      - [概念](#概念)
      - [领域建模](#领域建模)
      - [生命周期](#生命周期)
      - [软件系统架构风格](#软件系统架构风格)
        - [经典分层架构（N-Tier Architecture）](#经典分层架构n-tier-architecture)
        - [事件驱动型架构（Event-Driven Architecture）](#事件驱动型架构event-driven-architecture)
        - [微服务架构（Microservices Architecture）](#微服务架构microservices-architecture)
  - [TDD(UTDD)：测试驱动开发](#tddutdd测试驱动开发)
      - [测试驱动开发是敏捷开发中的一项核心实践和技术，](#测试驱动开发是敏捷开发中的一项核心实践和技术)
      - [TDD流程](#tdd流程)
      - [TDD 的三条规则](#tdd-的三条规则)
      - [好的单元测试应该符合几条原则：](#好的单元测试应该符合几条原则)
      - [TDD 编码方式](#tdd-编码方式)
      - [TDD（测试驱动开发）相关测试框架](#tdd测试驱动开发相关测试框架)
      - [测试驱动开发的基本过程](#测试驱动开发的基本过程)
      - [测试驱动开发的原则](#测试驱动开发的原则)
  - [BDD：行为驱动开发](#bdd行为驱动开发)
- [架构设计](#架构设计)
    - [定义](#定义)
      - [说明](#说明)
      - [影响因素](#影响因素)
    - [开发质量属性](#开发质量属性)
      - [开发期](#开发期)
    - [模型](#模型)
    - [4+1视图](#41视图)
  - [概设](#概设)
  - [详设](#详设)
  - [编码](#编码)
  - [测试](#测试)
  - [验收](#验收)
- [系统架构](#系统架构)
  - [模型](#模型-1)
    - [结构模型](#结构模型)
    - [框架模型](#框架模型)
    - [动态模型](#动态模型)
    - [过程模型](#过程模型)
    - [功能模型](#功能模型)
  - [4+1视图](#41视图-1)
    - [逻辑视图](#逻辑视图)
    - [进程视图](#进程视图)
    - [物理视图](#物理视图)
    - [场景视图](#场景视图)
  - [开发质量属性](#开发质量属性-1)
    - [运行期](#运行期)
      - [性能](#性能)
      - [安全](#安全)
      - [易用](#易用)
      - [可伸缩](#可伸缩)
      - [互操作](#互操作)
      - [可靠](#可靠)
      - [持续可用](#持续可用)
      - [鲁棒](#鲁棒)
    - [开发期](#开发期-1)
      - [易理解性](#易理解性)
      - [可扩展性](#可扩展性)
      - [可重用性](#可重用性)
      - [可测试性](#可测试性)
      - [可维护性](#可维护性)
      - [可移植性](#可移植性)
  - [企业架构成熟度模型（EAMM）](#企业架构成熟度模型eamm)
    - [EAMM从以下几个方面来对不同级别进行描述:](#eamm从以下几个方面来对不同级别进行描述)
      - [Administration – 治理角色与职责](#administration--治理角色与职责)
      - [Planning – 企业架构开发路标以及实现计划](#planning--企业架构开发路标以及实现计划)
      - [Framework – 流程和模板](#framework--流程和模板)
      - [Blueprint – 实际的标准和规范集合](#blueprint--实际的标准和规范集合)
      - [Communication – 交流与发布EA和详细蓝图](#communication--交流与发布ea和详细蓝图)
      - [Compliance（一致性） – 遵循发布的标准、流程和其它EA元素，文档化流程并且能够跟踪变化](#compliance一致性--遵循发布的标准流程和其它ea元素文档化流程并且能够跟踪变化)
      - [Integration – touch-points of management processes to the EA](#integration--touch-points-of-management-processes-to-the-ea)
      - [Involvement – 整个组织对EA的支持](#involvement--整个组织对ea的支持)
    - [分级](#分级)
      - [EA LEVEL 0 - NO PROGRAM](#ea-level-0---no-program)
      - [EA LEVEL 1 - INFORMAL PROGRAM](#ea-level-1---informal-program)
      - [EA LEVEL 2 - REPEATABLE PROGRAM](#ea-level-2---repeatable-program)
  - [软件分层](#软件分层)
    - [分层原则](#分层原则)
    - [框架模型](#框架模型-1)
  - [微服务](#微服务)
  - [consul](#consul)
  - [自动化测试](#自动化测试)
- [敏捷开发](#敏捷开发)
  - [敏捷软件开发宣言](#敏捷软件开发宣言)
    - [个人与交互 高于 流程和工具](#个人与交互-高于-流程和工具)
    - [可用软件 高于 详尽的文档](#可用软件-高于-详尽的文档)
    - [客户合作 高于 合同谈判](#客户合作-高于-合同谈判)
    - [响应变化 高于 遵循计划](#响应变化-高于-遵循计划)
  - [敏捷宣言的十二条原则](#敏捷宣言的十二条原则)
    - [我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。](#我们最重要的目标是通过持续不断地及早交付有价值的软件使客户满意)
    - [欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。](#欣然面对需求变化即使在开发后期也一样为了客户的竞争优势敏捷过程掌控变化)
    - [经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。](#经常地交付可工作的软件相隔几星期或一两个月倾向于采取较短的周期)
    - [业务人员和开发人员必须相互合作，项目中的每一天都不例外。](#业务人员和开发人员必须相互合作项目中的每一天都不例外)
    - [激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。](#激发个体的斗志以他们为核心搭建项目提供所需的环境和支援辅以信任从而达成目标)
    - [不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。](#不论团队内外传递信息效果最好效率也最高的方式是面对面的交谈)
    - [可工作的软件是进度的首要度量标准。](#可工作的软件是进度的首要度量标准)
    - [敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。](#敏捷过程倡导可持续开发责任人开发人员和用户要能够共同维持其步调稳定延续)
    - [坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。](#坚持不懈地追求技术卓越和良好设计敏捷能力由此增强)
    - [以简洁为本，它是极力减少不必要工作量的艺术。](#以简洁为本它是极力减少不必要工作量的艺术)
    - [最好的架构、需求和设计出自自组织团队。](#最好的架构需求和设计出自自组织团队)
    - [团队定期地反思如何能提高成效，并依此调整自身的举止表现。](#团队定期地反思如何能提高成效并依此调整自身的举止表现)
  - [应该着重注意的点](#应该着重注意的点)
    - [需求在开发中的重要性](#需求在开发中的重要性)
      - [大量的开发过程告诉我，需求在软件开发过程中是极其重要的。传统的开发强调初期的需求调研及需要分析，这个过程对于一些正规的团队会产生大量的文档，而后交由开发展开产品生产。](#大量的开发过程告诉我需求在软件开发过程中是极其重要的传统的开发强调初期的需求调研及需要分析这个过程对于一些正规的团队会产生大量的文档而后交由开发展开产品生产)
      - [然而，事实却不是想象这么简单，无数的例子说明了一点，仅仅在需求调研过程中了解到的需求是无法保证的。数不清的例子告诉我们，需求是会变的，变的原因很多。在极端的情况下，有些客户签字的需求在开发完后，有需要变更也很正常。](#然而事实却不是想象这么简单无数的例子说明了一点仅仅在需求调研过程中了解到的需求是无法保证的数不清的例子告诉我们需求是会变的变的原因很多在极端的情况下有些客户签字的需求在开发完后有需要变更也很正常)
      - [所以需求是影响软件开发的第一重要因素，需求来源于业务，我们开发的产品不就是因为这些业务才去做的吗？如何需求都无法把握好，还谈什么开发出好用的产品？](#所以需求是影响软件开发的第一重要因素需求来源于业务我们开发的产品不就是因为这些业务才去做的吗如何需求都无法把握好还谈什么开发出好用的产品)
      - [然而如何做好需求呢？我想首先要确立需求的地位，然后只有通过不断的沟通、尝试、反馈向真实需求迈进。](#然而如何做好需求呢我想首先要确立需求的地位然后只有通过不断的沟通尝试反馈向真实需求迈进)
    - [强调人与人的交流](#强调人与人的交流)
      - [不管怎么样开发过程中主要还是靠人的，而且软件开发是个复杂的团体工程，一个小些的产品也会涉及到各类人：客户、业务分析、管理人员、程序员、测试员等等。这么多人在一起做事情，有一方没有处理好结果肯定就会有问题。](#不管怎么样开发过程中主要还是靠人的而且软件开发是个复杂的团体工程一个小些的产品也会涉及到各类人客户业务分析管理人员程序员测试员等等这么多人在一起做事情有一方没有处理好结果肯定就会有问题)
      - [有这样一个例子：客户提出了一个会员管理功能需求，需求人员了解后组织了解决方案，于是交付了开发实现。而经过二个月无尽的黑夜之后交付，需求一看有个模块做的有偏差，但是已经来不及修改了。交给客户看后，发现这不是他们要的会员管理功能相差较大，另外在功能开发的这一段时间，客户又有了新想法，要对原先需求做调整。](#有这样一个例子客户提出了一个会员管理功能需求需求人员了解后组织了解决方案于是交付了开发实现而经过二个月无尽的黑夜之后交付需求一看有个模块做的有偏差但是已经来不及修改了交给客户看后发现这不是他们要的会员管理功能相差较大另外在功能开发的这一段时间客户又有了新想法要对原先需求做调整)
      - [这种例子可能大家经常经历吧？](#这种例子可能大家经常经历吧)
      - [这种问题在敏捷开发方法中提出了解决方法，就是通过不断的交付可用的制品。看起来很抽象，其实很简单。同样是上面的例子：](#这种问题在敏捷开发方法中提出了解决方法就是通过不断的交付可用的制品看起来很抽象其实很简单同样是上面的例子)
      - [Ø 客户提出会员管理功能需求](#ø-客户提出会员管理功能需求)
      - [Ø 需求人员在了解需求后与开发负责人商量，确定一个快迭代的开发计划，每二周向客户演示一次，并将这个计划与客户确认](#ø-需求人员在了解需求后与开发负责人商量确定一个快迭代的开发计划每二周向客户演示一次并将这个计划与客户确认)
      - [Ø 确认后需求人员向全体成员讲解需求背景故事](#ø-确认后需求人员向全体成员讲解需求背景故事)
      - [Ø 开发负责人组织并确定迭代计划内容，明确每个迭代提交的产品目标、开发任务安排、测试跟踪计划](#ø-开发负责人组织并确定迭代计划内容明确每个迭代提交的产品目标开发任务安排测试跟踪计划)
      - [Ø 每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏](#ø-每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏)
      - [Ø 后面就是每二周向客户演示一次产品，并获得客户的反馈](#ø-后面就是每二周向客户演示一次产品并获得客户的反馈)
      - [Ø 根据客户的反馈调整下个迭代计划，并继续下一个迭代](#ø-根据客户的反馈调整下个迭代计划并继续下一个迭代)
      - [Ø 直到产品交付](#ø-直到产品交付)
      - [通过上面的步骤，就不至于在开发完成后才知道用户的真实想法，因为很多用户对软件开发是没有概念的，他只知道自己有某种需求，但最开始是没有一个完整的概念的。所以就要通过不断的让用户看到产品的模型，这个过程用户才会逐步的对产品产生概念。同样的在过程中客户的提出需求变更也是在一定的可控制范围之内，这样一来可以大大的减少软件返工的情况，自然就不会拖延计划了。](#通过上面的步骤就不至于在开发完成后才知道用户的真实想法因为很多用户对软件开发是没有概念的他只知道自己有某种需求但最开始是没有一个完整的概念的所以就要通过不断的让用户看到产品的模型这个过程用户才会逐步的对产品产生概念同样的在过程中客户的提出需求变更也是在一定的可控制范围之内这样一来可以大大的减少软件返工的情况自然就不会拖延计划了)
      - [而这个过程中，需求已经完成了一个真正的过渡，不再是一头重的情况了。他让需求从客户那快速的反馈到开发团队中。同样的，在开发不断的交付制品时，需求也更加及时的了解到产品的进度，把握开发人员开发的功能是否符合需求。](#而这个过程中需求已经完成了一个真正的过渡不再是一头重的情况了他让需求从客户那快速的反馈到开发团队中同样的在开发不断的交付制品时需求也更加及时的了解到产品的进度把握开发人员开发的功能是否符合需求)
      - [当然这并不是一个标准做法，不同的团队可以有不同的处理方式。这里只是想强调需求需要更多的投入到开发过程中去，及时的与客户沟通交流，了解到客户的真实想法。](#当然这并不是一个标准做法不同的团队可以有不同的处理方式这里只是想强调需求需要更多的投入到开发过程中去及时的与客户沟通交流了解到客户的真实想法)
    - [强调文档的作用](#强调文档的作用)
      - [我觉得很多对敏捷开发的一个误解就是不需要文档，敏捷开发并未抛弃文档。只是更强调更有效的方式使用文档。在很多传统开发方法中，特别是很多很正规的开发团队对文档的要求非常苛刻。然而事实是文档不易管理，最痛苦的是不好维护，文档需要随着变化而变化，比如需求调整、技术架构升级、产品维护等等。如果要保证文档的一致性，太难了。特别是对于一些无法进行有效管理的开发团队就更加明显，经常是软件已经几个版本了，文档却是两年前的。](#我觉得很多对敏捷开发的一个误解就是不需要文档敏捷开发并未抛弃文档只是更强调更有效的方式使用文档在很多传统开发方法中特别是很多很正规的开发团队对文档的要求非常苛刻然而事实是文档不易管理最痛苦的是不好维护文档需要随着变化而变化比如需求调整技术架构升级产品维护等等如果要保证文档的一致性太难了特别是对于一些无法进行有效管理的开发团队就更加明显经常是软件已经几个版本了文档却是两年前的)
      - [但敏捷真的不需要文档吗？我想不是的，如何把文档做到好维护我想才是最重要的。文档到底指的指的什么？什么样的算文档？](#但敏捷真的不需要文档吗我想不是的如何把文档做到好维护我想才是最重要的文档到底指的指的什么什么样的算文档)
      - [提出上面两个问题，我们先想想经常说的文档的作用是什么？不就是一个传播工具吗？可以用作记录、给他人看、用于以后查看。有很多方法可就解决了这个问题，比如wiki系统。维护一个wiki系统，可以随时写，随时维护，可以方便的查找。嗯，多方便。](#提出上面两个问题我们先想想经常说的文档的作用是什么不就是一个传播工具吗可以用作记录给他人看用于以后查看有很多方法可就解决了这个问题比如wiki系统维护一个wiki系统可以随时写随时维护可以方便的查找嗯多方便)
      - [另外一个问题就是什么样的工作需要形成文档呢？](#另外一个问题就是什么样的工作需要形成文档呢)
      - [记得在前一家公司，维护一个10多年的老系统修改一个公式计算的BUG，但是怎么也不知道这个复杂的公式是什么意思，问过了公司大部分的人也无人可解。这时想，如果当初有那么一份文档，谢天谢地。](#记得在前一家公司维护一个10多年的老系统修改一个公式计算的bug但是怎么也不知道这个复杂的公式是什么意思问过了公司大部分的人也无人可解这时想如果当初有那么一份文档谢天谢地)
      - [像这种关键的内容有份文档还是很重要的，否则随着时间推移，谁也不能保证能记得住当时为什么会这么干。](#像这种关键的内容有份文档还是很重要的否则随着时间推移谁也不能保证能记得住当时为什么会这么干)
      - [记得多年前一次记笔记的经历，我看了一篇文章了解了DELPHI实现单实例模式的方法，这种方法很酷。于是整理成了笔记写在了wiki上，第二天就得到了回复，帮助到了别外产品开发组的同事。](#记得多年前一次记笔记的经历我看了一篇文章了解了delphi实现单实例模式的方法这种方法很酷于是整理成了笔记写在了wiki上第二天就得到了回复帮助到了别外产品开发组的同事)
      - [嗯，文档就是这样他具有传播性，你不可能跑去跟所有人说出你的想法，但是文档却更容易达成。他也有传承性，有些文档也许10多年后又起了重要作用。](#嗯文档就是这样他具有传播性你不可能跑去跟所有人说出你的想法但是文档却更容易达成他也有传承性有些文档也许10多年后又起了重要作用)
    - [团队协作](#团队协作)
      - [1、减少对开发人员的干扰](#1减少对开发人员的干扰)
      - [曾经接手一个产品的开发，最初遇到一个很头痛的问题，原先写好的迭代计划，而且工作量也较大，大家都在忙着。即便在这样的状态下，客服人员却经常跑来找某个程序员A维护各种系统问题，程序员A在一次维护中竟然导致了系统数据出现大面积错误。程序员A心理上承受着巨大的压力，而每天的这些问题又不得不解决，加之新版本又有很重的开发任务无法完成，最终导致整个开发计划变更。](#曾经接手一个产品的开发最初遇到一个很头痛的问题原先写好的迭代计划而且工作量也较大大家都在忙着即便在这样的状态下客服人员却经常跑来找某个程序员a维护各种系统问题程序员a在一次维护中竟然导致了系统数据出现大面积错误程序员a心理上承受着巨大的压力而每天的这些问题又不得不解决加之新版本又有很重的开发任务无法完成最终导致整个开发计划变更)
      - [我无法再忍受，找到了需求及客服的负责人，沟通后发现这些问题很多都是重复性的，主要是因为原先系统的不足。于是回去组织人员做了几个后台临时功能，并交付给了客服人员，之后就没有再来找过这位程序员A。后续我又找到了客服负责人，要求不能直接找开发人员解决这类问题，并与负责人约定了处理过程。](#我无法再忍受找到了需求及客服的负责人沟通后发现这些问题很多都是重复性的主要是因为原先系统的不足于是回去组织人员做了几个后台临时功能并交付给了客服人员之后就没有再来找过这位程序员a后续我又找到了客服负责人要求不能直接找开发人员解决这类问题并与负责人约定了处理过程)
      - [这是个例子，在实际情况中还有很多这种事情，甚至有很多开发人员要直接面对客户。我想对于职能型团队来说，开发团队最好是减少这些方面的干忧。当然对于一个人包干的情况就不讨论了。](#这是个例子在实际情况中还有很多这种事情甚至有很多开发人员要直接面对客户我想对于职能型团队来说开发团队最好是减少这些方面的干忧当然对于一个人包干的情况就不讨论了)
      - [大部分的人都不是超人，在一个时间段内处理超出自己负荷的工作是很难做好保质保量的。所以对于开发管理人员一定要考虑到这点，尽量让开发人员有比较好的工作进度环境，通过外界的方式来解决一些开发团队的干扰。](#大部分的人都不是超人在一个时间段内处理超出自己负荷的工作是很难做好保质保量的所以对于开发管理人员一定要考虑到这点尽量让开发人员有比较好的工作进度环境通过外界的方式来解决一些开发团队的干扰)
      - [我接触过的很多程序员都很反感这种干扰，虽然有些人在这种全面的工作强度下成长很快，但是并非所有人都适应，长期下来会有怨恨和不快，工作效率会下降。心情舒畅还是很重要的，记得有一次迭代总结时，有个程序员总结说：发现心情舒畅自己的工作效率很高。呵呵。我想你也有同感吧。](#我接触过的很多程序员都很反感这种干扰虽然有些人在这种全面的工作强度下成长很快但是并非所有人都适应长期下来会有怨恨和不快工作效率会下降心情舒畅还是很重要的记得有一次迭代总结时有个程序员总结说发现心情舒畅自己的工作效率很高呵呵我想你也有同感吧)
      - [2、不要忽略测试人员在开发阶段的作用](#2不要忽略测试人员在开发阶段的作用)
      - [曾经多少次在项目发布前加班到深夜2点的情景还历历在目，那种感觉即快乐又痛苦。由于和客户签定的合同的交付日期就要到了，产品却迟迟未集成完成，测试只能干等着上网聊QQ。就在下班前的一刻发布了，测试开始了紧张的测试，在屏幕闪动中，一个个的BUG提交，直到流程都无法都走不下去，测试无奈了。第二天就要发布，实施人员就等着制品第二天出差。只有不断的改，再发布，无尽的循环。直到大家都憔悴的看着老大，终于老大说：还剩下的这几个问题无关紧要，大家回去吧。](#曾经多少次在项目发布前加班到深夜2点的情景还历历在目那种感觉即快乐又痛苦由于和客户签定的合同的交付日期就要到了产品却迟迟未集成完成测试只能干等着上网聊qq就在下班前的一刻发布了测试开始了紧张的测试在屏幕闪动中一个个的bug提交直到流程都无法都走不下去测试无奈了第二天就要发布实施人员就等着制品第二天出差只有不断的改再发布无尽的循环直到大家都憔悴的看着老大终于老大说还剩下的这几个问题无关紧要大家回去吧)
      - [几个月的开发过去后在总结会上，只能抱怨测试资源不足，时间太短，需求更改太多，需求更改后测试不知道。无数的问题一次一次的出现在同样的总结会议上。](#几个月的开发过去后在总结会上只能抱怨测试资源不足时间太短需求更改太多需求更改后测试不知道无数的问题一次一次的出现在同样的总结会议上)
      - [上面的这个例子很多人应该经历过，真的测试只有最后一刻才能体现价值吗？我想不是的。](#上面的这个例子很多人应该经历过真的测试只有最后一刻才能体现价值吗我想不是的)
      - [在后面的项目中我总结了这个问题的，针对每个开发任务要求进行测试验证。而测试如何验证呢？他需要知道这个开发任务的需求是如何，提前做好测试计划及测试用例，在接到开发制品后测试并提交BUG，这个工作是可以开发过程中就能不断的进行的。保证每一个任务的质量，可以大大减少后期集成的错误量。](#在后面的项目中我总结了这个问题的针对每个开发任务要求进行测试验证而测试如何验证呢他需要知道这个开发任务的需求是如何提前做好测试计划及测试用例在接到开发制品后测试并提交bug这个工作是可以开发过程中就能不断的进行的保证每一个任务的质量可以大大减少后期集成的错误量)
      - [另外根据敏捷开发的思想，测试团队在开发过程中也需要加强与开发团队的交流，甚至有必要组成虚拟团队，位置调整到一起，这样可以及时快速的交流，参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度，反过来把握测试计划及测试内容。](#另外根据敏捷开发的思想测试团队在开发过程中也需要加强与开发团队的交流甚至有必要组成虚拟团队位置调整到一起这样可以及时快速的交流参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度反过来把握测试计划及测试内容)
      - [特别是测试从另一个角度来审视需求，这样也可以一定程度上发现或者改善需求上的不足。](#特别是测试从另一个角度来审视需求这样也可以一定程度上发现或者改善需求上的不足)
      - [3、发挥团队人员的潜力](#3发挥团队人员的潜力)
      - [敏捷开发比较提倡开发任务由开发自己评估并认领工作任务，这样可以激发开发的潜在动力。](#敏捷开发比较提倡开发任务由开发自己评估并认领工作任务这样可以激发开发的潜在动力)
      - [之前在做一个新产品时，需要使用java，而我们团队是使用C#的，面临转型问题。而有一位同事很感兴趣，于是我就让他负责前期的框架探索与搭建。结果就是这位小伙工作效率很高，我最初给他的目标全部都完成了。最有意思的是后面产品开始研发时，这位小伙已经成为了团队的大牛，大家有问题都找他解决。也正是因为这个过程，这位小伙被全面激活，也在大家面前展示了能力。甚至在小伙离职时也被领导给予大幅涨薪来挽留。只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢!](#之前在做一个新产品时需要使用java而我们团队是使用c的面临转型问题而有一位同事很感兴趣于是我就让他负责前期的框架探索与搭建结果就是这位小伙工作效率很高我最初给他的目标全部都完成了最有意思的是后面产品开始研发时这位小伙已经成为了团队的大牛大家有问题都找他解决也正是因为这个过程这位小伙被全面激活也在大家面前展示了能力甚至在小伙离职时也被领导给予大幅涨薪来挽留只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢)
      - [所以充分发挥好每个人员的特点，让人能够在自己感兴趣的工作中，效果会很多。减少指派方式的任务的分配，充分发挥个人的主动性，这个团队精神面貌也会好很多。](#所以充分发挥好每个人员的特点让人能够在自己感兴趣的工作中效果会很多减少指派方式的任务的分配充分发挥个人的主动性这个团队精神面貌也会好很多)
      - [4、管理者不要离团队太远](#4管理者不要离团队太远)
      - [作为团队的Leader要参与到团队的工作中去，比如一个开发主管一定要写写代码，参与架构等对项目有关的事情，而不是在那里分分任务。这样团队成员才会觉得这个Leader很亲近感。](#作为团队的leader要参与到团队的工作中去比如一个开发主管一定要写写代码参与架构等对项目有关的事情而不是在那里分分任务这样团队成员才会觉得这个leader很亲近感)
      - [特别是有些开发主管在带队后离团队越来越远，有时对于开发进度不如意时就说：“这么个简单功能怎么会搞了这么久？”，其实每天都在加班的同事心里想着：“有本事你来？”，即使这个小组长有这个能力，但对于团队来说也不是一件好事，因为大家都抱有怨恨之心，还谈什么好好工作呢？这个小组长就是失职的。所以这种情况下应该主动去了解进度滞后的原因，并且自己要加入到解决问题的工作中去，而不是在边上抱怨别人。](#特别是有些开发主管在带队后离团队越来越远有时对于开发进度不如意时就说这么个简单功能怎么会搞了这么久其实每天都在加班的同事心里想着有本事你来即使这个小组长有这个能力但对于团队来说也不是一件好事因为大家都抱有怨恨之心还谈什么好好工作呢这个小组长就是失职的所以这种情况下应该主动去了解进度滞后的原因并且自己要加入到解决问题的工作中去而不是在边上抱怨别人)
      - [5、小组织不要搞太多的官](#5小组织不要搞太多的官)
      - [中国几千年的文化，官本位一直影响着我们，大家都想坐在那指挥，自己啥事也不用干，想想都惬意。在我们这个行业是不是发现也很类似？大家都想着干几年当个小组长，然后升个部门经理，当上CTO迎娶白富美。](#中国几千年的文化官本位一直影响着我们大家都想坐在那指挥自己啥事也不用干想想都惬意在我们这个行业是不是发现也很类似大家都想着干几年当个小组长然后升个部门经理当上cto迎娶白富美)
      - [团队的管理基本是事与人的管理，非常的伤脑和心。如果一个组织内，特别是小组织内“官”太多，协调就会非常的难，大家就会经常性的扯皮。](#团队的管理基本是事与人的管理非常的伤脑和心如果一个组织内特别是小组织内官太多协调就会非常的难大家就会经常性的扯皮)
      - [结束](#结束)
  - [敏捷开发的推理](#敏捷开发的推理)
    - [符合现实的软件](#符合现实的软件)
    - [软件是为着解决现实的问题而产生的。从而软件存在的意义就是与现实相适应。敏捷开发的核心即：符合现实的软件。一个符合现实的软件，才能够可持续地与现实共同发展。一旦软件与现实背离，软件的生命周期也就到了结束的时候了。](#软件是为着解决现实的问题而产生的从而软件存在的意义就是与现实相适应敏捷开发的核心即符合现实的软件一个符合现实的软件才能够可持续地与现实共同发展一旦软件与现实背离软件的生命周期也就到了结束的时候了)
    - [现实的世界是动态变化的，人类造出来的东西，往往是落后于世界的变化的。如，地图造出来之后，可能又多修了几条路，几个建筑；刚买了一款高配置的计算机，几个月后，自己的机器配置又处于被甩的地位了……这些变化，人是被迫要去接受。因为这些东西属于硬件，人在目前还无法轻易地改变硬件。](#现实的世界是动态变化的人类造出来的东西往往是落后于世界的变化的如地图造出来之后可能又多修了几条路几个建筑刚买了一款高配置的计算机几个月后自己的机器配置又处于被甩的地位了这些变化人是被迫要去接受因为这些东西属于硬件人在目前还无法轻易地改变硬件)
    - [而与此不同的软件，则是另外一种现象了。改变软件的代价是相当低廉的。改变软件，实际上只是改变硬盘上的磁性。改变软件的容易性，带来的结果是： 一、软件开发者容易以自己的想象来决定软件怎么做。 开发出一个无用的软件，比起因为出错而要毁掉待出售的10万张地图，比起因为工艺漏洞而要招回已经出售的计算机来讲，代价太低廉了。 二、软件更加具备符合现实的条件。 开发者让软件与现实相适应，所要付出的代价非常低廉。](#而与此不同的软件则是另外一种现象了改变软件的代价是相当低廉的改变软件实际上只是改变硬盘上的磁性改变软件的容易性带来的结果是-一软件开发者容易以自己的想象来决定软件怎么做-开发出一个无用的软件比起因为出错而要毁掉待出售的10万张地图比起因为工艺漏洞而要招回已经出售的计算机来讲代价太低廉了-二软件更加具备符合现实的条件-开发者让软件与现实相适应所要付出的代价非常低廉)
    - [所以，敏捷开发的核心就是符合现实的软件。为了造出符合现实的软件，才有了进一步的价值观及方法论。](#所以敏捷开发的核心就是符合现实的软件为了造出符合现实的软件才有了进一步的价值观及方法论)
    - [简单](#简单)
    - [简单，是在人认识到事物的本质的时候才能够获得的。在开发软件的时候，我们往往疲于应付各种各样的需求。很少有人能够将复杂的需求化为简单的概念。比如，做一个音乐软件，有“我喜欢的”、“最近播放”、“最新添加”等不同的性质的歌。有些开发者会做出三个列表来存放三种性质的歌。而实际上他们的本质是一样的，即播放列表。区别在于触发加入播放列表的条件不同而已。因而只需要做一个列表，在列表中标记每首歌的触发条件。](#简单是在人认识到事物的本质的时候才能够获得的在开发软件的时候我们往往疲于应付各种各样的需求很少有人能够将复杂的需求化为简单的概念比如做一个音乐软件有我喜欢的最近播放最新添加等不同的性质的歌有些开发者会做出三个列表来存放三种性质的歌而实际上他们的本质是一样的即播放列表区别在于触发加入播放列表的条件不同而已因而只需要做一个列表在列表中标记每首歌的触发条件)
    - [把软件做得很复杂，通常说明软件所抓住的本质还很少。需要再好好考虑一下如何进一步进行简化。软件的概念简单，一方面可以让用户很容易理解和操作；另一方面能够适应世界的变化。再拿以上的音乐软件来说。如何做成三个列表，再要加一个“听了又听”的歌，又得创建一个列表。而使用一个列表的方法，则只需要处理“听了又听”这个触发条件。](#把软件做得很复杂通常说明软件所抓住的本质还很少需要再好好考虑一下如何进一步进行简化软件的概念简单一方面可以让用户很容易理解和操作另一方面能够适应世界的变化再拿以上的音乐软件来说如何做成三个列表再要加一个听了又听的歌又得创建一个列表而使用一个列表的方法则只需要处理听了又听这个触发条件)
    - [符合现实的软件必然是简单的。所以，敏捷开发的第一条价值观是：简单。我们在实施敏捷开发的时候，都是围绕“简单”这一价值观而进行实施的。即，时刻保证软件的简单性。简单性包括两个方面：一是对于用户而言，概念很简单；二是对于开发者而言，开发的技术及代码很简单。](#符合现实的软件必然是简单的所以敏捷开发的第一条价值观是简单我们在实施敏捷开发的时候都是围绕简单这一价值观而进行实施的即时刻保证软件的简单性简单性包括两个方面一是对于用户而言概念很简单二是对于开发者而言开发的技术及代码很简单)
    - [软件的可持续性也取决于软件是否简单。可持续性是指，快速响应现实的变化。一个复杂的软件，要么让用户无所适从，要么让代码无法维护。这都将导致软件无法持续。这会迫使我们以制造硬件的方式来开发软件。硬件是在迫不得已的情况下才丢掉重新升级（计算机在实在没有办法用的时候，才买新的），要让软件也这样做，软件开发低廉代价的优势就白白浪费掉了。](#软件的可持续性也取决于软件是否简单可持续性是指快速响应现实的变化一个复杂的软件要么让用户无所适从要么让代码无法维护这都将导致软件无法持续这会迫使我们以制造硬件的方式来开发软件硬件是在迫不得已的情况下才丢掉重新升级计算机在实在没有办法用的时候才买新的要让软件也这样做软件开发低廉代价的优势就白白浪费掉了)
    - [反馈](#反馈)
    - [一个软件要符合现实，就需要通过现实的反馈来发展。软件前进的动力是现实的反馈。敏捷开发是欢迎现实，拥抱变化的开发。强调该条价值观，是为了消除开发者容易犯的错误——以自己的想象去决定软件怎么做。](#一个软件要符合现实就需要通过现实的反馈来发展软件前进的动力是现实的反馈敏捷开发是欢迎现实拥抱变化的开发强调该条价值观是为了消除开发者容易犯的错误以自己的想象去决定软件怎么做)
    - [因而，在做一个软件之前，首先要找到能够给出反馈的人。如果连能够给出反馈的人都没有，那么这个软件就没有做的必要了。](#因而在做一个软件之前首先要找到能够给出反馈的人如果连能够给出反馈的人都没有那么这个软件就没有做的必要了)
    - [反馈的重要性，更可以这样说：矛盾推动事物的发展。反馈是指出不足的矛，软件是弥补不足的盾。在矛的不断攻击之下，盾才能不断完善。矛之不存，盾何以壮。](#反馈的重要性更可以这样说矛盾推动事物的发展反馈是指出不足的矛软件是弥补不足的盾在矛的不断攻击之下盾才能不断完善矛之不存盾何以壮)
    - [在方法论上面，敏捷开发强调快速发布版本，取得现实的反馈而不是开发者大脑中自己想像的反馈。如果开发者正好也是使用者，那么软件做成的几率就要大很多。开源软件大多数都是开发者自己要解决问题而产生的。](#在方法论上面敏捷开发强调快速发布版本取得现实的反馈而不是开发者大脑中自己想像的反馈如果开发者正好也是使用者那么软件做成的几率就要大很多开源软件大多数都是开发者自己要解决问题而产生的)
    - [沟通](#沟通)
    - [沟通是开发者取得反馈的手段。一个优秀的开发者，是善于沟通的。沟通包含口语、写文档等各种方式。优秀的开发者应该能够清晰而有条理地表达自己的想法。](#沟通是开发者取得反馈的手段一个优秀的开发者是善于沟通的沟通包含口语写文档等各种方式优秀的开发者应该能够清晰而有条理地表达自己的想法)
    - [现实世界中，人们普遍认为：软件开发者因为跟机器打交道，从而是内向的，不善于沟通的。实际上，这样的开发者不能算是优秀的。他们所做的事情，更多地是把需求转化为计算机语言的工作，即翻译员。而现在都出来谷歌翻译了，人类语言翻译成计算机语言只是时间问题了。](#现实世界中人们普遍认为软件开发者因为跟机器打交道从而是内向的不善于沟通的实际上这样的开发者不能算是优秀的他们所做的事情更多地是把需求转化为计算机语言的工作即翻译员而现在都出来谷歌翻译了人类语言翻译成计算机语言只是时间问题了)
    - [沟通的目的是进行思想碰撞。在沟通当中了解别人的思维方式，表达自己的思维方式，进一步扬弃为更加优秀的思维方式。在优秀的思维方式之下才能保持让自己与现实相符合。优秀的开发者是不会放弃获取优秀的思维方式的机会的。](#沟通的目的是进行思想碰撞在沟通当中了解别人的思维方式表达自己的思维方式进一步扬弃为更加优秀的思维方式在优秀的思维方式之下才能保持让自己与现实相符合优秀的开发者是不会放弃获取优秀的思维方式的机会的)
    - [在敏捷开发当中，提出这一价值观，正是要开发者变得优秀。放弃优秀的开发者无法适应敏捷开发。](#在敏捷开发当中提出这一价值观正是要开发者变得优秀放弃优秀的开发者无法适应敏捷开发)
    - [勇气](#勇气)
    - [在现实生活中，缺乏勇气比较常见。比如，不敢大大方方地表白，不敢尝试新的事物……在软件开发领域，缺乏勇气更是常见：技术更新好几代了，公司还不敢使用新技术；公司不敢尝试新的开发模式（敏捷开发）……](#在现实生活中缺乏勇气比较常见比如不敢大大方方地表白不敢尝试新的事物在软件开发领域缺乏勇气更是常见技术更新好几代了公司还不敢使用新技术公司不敢尝试新的开发模式敏捷开发)
    - [勇气，本质上来讲，是对现状的否定。人们往往一厢情愿地相信永恒；一旦确定，就不愿意改变。这正是勇气的用武之地。勇气使人去否定永恒，拥抱改变。勇气是创造的源泉。人没有勇气，人就永远是他现在的这样了，正是勇气才迫使他去改变。](#勇气本质上来讲是对现状的否定人们往往一厢情愿地相信永恒一旦确定就不愿意改变这正是勇气的用武之地勇气使人去否定永恒拥抱改变勇气是创造的源泉人没有勇气人就永远是他现在的这样了正是勇气才迫使他去改变)
    - [在开发的时候，我们可能花了很多时间写了很多代码，但要决定放弃已经写过的所有代码，这是非常需要勇气的。而如果能够做到这一点，在软件开发上就占据了非常有利的位置。比如，我们可能会花大量时间去写页面原型，以希望能够得到用户反馈。在确定得到用户反馈之后，我们可以完全放弃原型代码，进而可以得到更加符合现实（也更加简单）的代码。](#在开发的时候我们可能花了很多时间写了很多代码但要决定放弃已经写过的所有代码这是非常需要勇气的而如果能够做到这一点在软件开发上就占据了非常有利的位置比如我们可能会花大量时间去写页面原型以希望能够得到用户反馈在确定得到用户反馈之后我们可以完全放弃原型代码进而可以得到更加符合现实也更加简单的代码)
    - [敏捷开发强调勇气这一价值观，正是要开发者去拥抱现实的变化，让开发者及软件朝着符合现实的路线走。](#敏捷开发强调勇气这一价值观正是要开发者去拥抱现实的变化让开发者及软件朝着符合现实的路线走)
    - [迭代开发](#迭代开发)
    - [讲完四个价值观之后，接下来我把四个价值观联系起来，得到一个方法论——迭代开发。](#讲完四个价值观之后接下来我把四个价值观联系起来得到一个方法论迭代开发)
    - [如图所示，简单是软件开发的起点，也是软件开发的终点。](#如图所示简单是软件开发的起点也是软件开发的终点)
    - [说它是起点，是因为，如果开发的东西还是复杂的，那就有必要把概念弄得简单一些。这包含两个方面的行动：一、把复杂的系统砍掉一半的功能（广度上）；二、尽可能对各个功能进行抽象（深度上，参考前面音乐软件的例子）。](#说它是起点是因为如果开发的东西还是复杂的那就有必要把概念弄得简单一些这包含两个方面的行动一把复杂的系统砍掉一半的功能广度上二尽可能对各个功能进行抽象深度上参考前面音乐软件的例子)
    - [接下来，我们拿着简单的软件（或者软件原型）进入沟通环节。我们可以在两个方面进行沟通：一、与用户沟通软件的逻辑是否满足要求；二、与开发者沟通软件是否在技术上代价很高，如何权衡。](#接下来我们拿着简单的软件或者软件原型进入沟通环节我们可以在两个方面进行沟通一与用户沟通软件的逻辑是否满足要求二与开发者沟通软件是否在技术上代价很高如何权衡)
    - [沟通之后，我们可以得到现实的反馈，在现实的反馈之下，我们才有勇气进行改变，使用我们的软件继续维持其简单性。这就完成了软件的一个迭代。](#沟通之后我们可以得到现实的反馈在现实的反馈之下我们才有勇气进行改变使用我们的软件继续维持其简单性这就完成了软件的一个迭代)
  - [敏捷方法](#敏捷方法)
    - [Scrum](#scrum)
      - [Scrum是和种迭代式及递增式的敏捷软件开发框架，它用于管理软件项目，产品，或程序的开发。它的着重点是一个灵活的，全面的产品开发策略，它把一个开发团队通常作为一个单位进而实现一个常规目的。相反，它不着重于传递的序列化式的方法。Scrum会问传统瀑布式开发“为什么我们要花费这么长时间，这么多努力去做一件事？为什么我们不能衡量出做一件事所需时间和人力？” Scrum拥抱变化和创造力，因为这是人们的工作方式。Scrum有一个流程学习结构，能够让团队评估他们做了什么以及他们怎样做的。](#scrum是和种迭代式及递增式的敏捷软件开发框架它用于管理软件项目产品或程序的开发它的着重点是一个灵活的全面的产品开发策略它把一个开发团队通常作为一个单位进而实现一个常规目的相反它不着重于传递的序列化式的方法scrum会问传统瀑布式开发为什么我们要花费这么长时间这么多努力去做一件事为什么我们不能衡量出做一件事所需时间和人力-scrum拥抱变化和创造力因为这是人们的工作方式scrum有一个流程学习结构能够让团队评估他们做了什么以及他们怎样做的)
      - [Scrum角色](#scrum角色)
        - [产品持有人 Product Owner](#产品持有人-product-owner)
        - [开发团队 Development Team](#开发团队-development-team)
        - [Scrum领导人 ScrumMaster](#scrum领导人-scrummaster)
      - [会议](#会议)
        - [1、Sprint计划会议](#1sprint计划会议)
        - [2、每日例会](#2每日例会)
        - [3、Sprint评审会议](#3sprint评审会议)
        - [4、Sprint回顾会议](#4sprint回顾会议)
      - [三个构件](#三个构件)
        - [1、产品Backlog  产品Backlog指根据初始需求分解出的任务列表，包括功能性和非功能性的所有功能。](#1产品backlog--产品backlog指根据初始需求分解出的任务列表包括功能性和非功能性的所有功能)
        - [2、Sprint Backlog Sprint Backlog就是任务列表，如果映射到传统的项目管理理论中就是WBS（work breakdown structure)，而且是典型的采用面向交付物的任务分解方法得到的WBS。](#2sprint-backlog-sprint-backlog就是任务列表如果映射到传统的项目管理理论中就是wbswork-breakdown-structure而且是典型的采用面向交付物的任务分解方法得到的wbs)
        - [3、燃尽图。](#3燃尽图)
      - [完成Scrum敏捷开发的流程为：](#完成scrum敏捷开发的流程为)
        - [第一步：Product Backing   找出完成产品需要做的事情。](#第一步product-backing---找出完成产品需要做的事情)
        - [第二步:Sprint Backlog   决定当前冲刺需要解决的事情。](#第二步sprint-backlog---决定当前冲刺需要解决的事情)
        - [第三步：Sprint   冲刺。](#第三步sprint---冲刺)
        - [第四步：得到软件的一个增量版本，发布给用户。然后在此基础上进一步计划增量的新功能和改进。](#第四步得到软件的一个增量版本发布给用户然后在此基础上进一步计划增量的新功能和改进)
      - [Scrum开发的一些注意事项：](#scrum开发的一些注意事项)
        - [1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；](#1我们首先需要确定一个product-backlog按优先顺序排列的一个产品需求列表这个是由product-owner-负责的)
        - [2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；](#2scrum-team根据product-backlog列表做工作量的预估和安排)
        - [3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；](#3有了product-backlog列表我们需要通过-sprint-planning-meetingsprint计划会议-来从中挑选出一个story作为本次迭代完成的目标这个目标的时间周期是14个星期然后把这个story进行细化形成一个sprint-backlog)
        - [4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；](#4sprint-backlog是由scrum-team去完成的每个成员根据sprint-backlog再细化成更小的任务细到每个任务的工作量在2天内能完成)
        - [5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天 要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；](#5在scrum-team完成计划会议上选出的sprint-backlog过程中需要进行-daily-scrum-meeting每日站立会议每次会议控制在15分钟左右每个人都必须发言并且要向所有成员当面汇报你昨天完成了什么并且向所有成员承诺你今天-要完成什么同时遇到不能解决的问题也可以提出每个人回答完成后要走到黑板前更新自己的-sprint-burn-downsprint燃尽图)
        - [6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可 以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本 发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；](#6做到每日集成也就是每天都要有一个可以成功编译并且可以演示的版本很多人可能还没有用过自动化的每日集成其实tfs就有这个功能它可-以支持每次有成员进行签入操作的时候在服务器上自动获取最新版本然后在服务器中编译如果通过则马上再执行单元测试代码如果也全部通过则将该版本-发布这时一次正式的签入操作才保存到tfs中中间有任何失败都会用邮件通知项目管理人员)
        - [7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；](#7当一个story完成也就是sprint-backlog被完成也就表示一次sprint完成这时我们要进行-srpint-review-meeting演示会议也称为评审会议产品负责人和客户都要参加最好本公司老板也参加每一个scrum-team的成员都要向他们演示自己完成的软件产品这个会议非常重要一定不能取消)
        - [8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；](#8最后就是-sprint-retrospective-meeting回顾会议也称为总结会议以轮流发言方式进行每个人都要发言总结并讨论改进的地方放入下一轮sprint的产品需求中)
      - [需求收集](#需求收集)
        - [1.1  需求的分类](#11--需求的分类)
        - [1.2  需求提交模板](#12--需求提交模板)
        - [② 优先级 可从以下五种情况中选择](#-优先级-可从以下五种情况中选择)
        - [③ 需求类型 可以是两种类型](#-需求类型-可以是两种类型)
        - [④ 需求标题 有自己进行书写，但是需要遵守的规范是采用动宾短语格式。](#-需求标题-有自己进行书写但是需要遵守的规范是采用动宾短语格式)
        - [⑤ 详细描述 需要按照用户故事的格式进行书写。具体用户故事格式的要求如下：](#-详细描述-需要按照用户故事的格式进行书写具体用户故事格式的要求如下)
        - [用户故事是从用户的角度来描述用户渴望得到的功能。需要注意的是用户故事不能够使用技术语言来描述，要使用用户可以理解的业务语言来描述。一个好的用户故事包括三个要素：](#用户故事是从用户的角度来描述用户渴望得到的功能需要注意的是用户故事不能够使用技术语言来描述要使用用户可以理解的业务语言来描述一个好的用户故事包括三个要素)
        - [用户故事通常按照如下的格式来表达：作为一个\<角色\>, 我想要\<活动\>, 以便于\<商业价值\>](#用户故事通常按照如下的格式来表达作为一个角色-我想要活动-以便于商业价值)
        - [比如：作为一名酒店前端开发人员，我期望查看所有酒店页面的页面打开时间，以便了解哪些页面需要进行技能优化。](#比如作为一名酒店前端开发人员我期望查看所有酒店页面的页面打开时间以便了解哪些页面需要进行技能优化)
        - [一个好的用户故事同时要符合INVEST原则，INVEST原则分别是：](#一个好的用户故事同时要符合invest原则invest原则分别是)
        - [注意：](#注意)
        - [角色的范围不能过大，比如是作为一名“用户”，这样是的不被接受的。](#角色的范围不能过大比如是作为一名用户这样是的不被接受的)
        - [商业价值也不能大而宽泛，比如，能为公司创造业绩。如果要写也一定要对业绩做初步估算，比如，预期会给公司带来每月1万张订单。](#商业价值也不能大而宽泛比如能为公司创造业绩如果要写也一定要对业绩做初步估算比如预期会给公司带来每月1万张订单)
        - [⑥ 验收条件 是开发完成后检验的标准，所以一定要认真填写，否则可能开发出来的东西与预期不达标。](#-验收条件-是开发完成后检验的标准所以一定要认真填写否则可能开发出来的东西与预期不达标)
        - [⑦   价值验证 说明如何跟踪上线后的效果](#---价值验证-说明如何跟踪上线后的效果)
      - [Sprint 计划会议 1](#sprint-计划会议-1)
        - [目标：定出 Sprint 目标和既定产品 Backlog。](#目标定出-sprint-目标和既定产品-backlog)
        - [2.1 会议准备](#21-会议准备)
        - [2.2 会议议程](#22-会议议程)
        - [2.3 会议结果](#23-会议结果)
        - [2.4 补充内容](#24-补充内容)
      - [Sprint 计划会议 2](#sprint-计划会议-2)
        - [3.1 会议准备](#31-会议准备)
        - [3.2 会议进程](#32-会议进程)
        - [3.3 会议结果](#33-会议结果)
        - [3.4 补充内容](#34-补充内容)
      - [Scrum 每日例会](#scrum-每日例会)
        - [目标：团队成员间工作进度的沟通和协调](#目标团队成员间工作进度的沟通和协调)
        - [4.1 会议准备](#41-会议准备)
        - [4.2 会议进程](#42-会议进程)
        - [4.3 会议结果](#43-会议结果)
      - [Sprint 验收会议](#sprint-验收会议)
        - [目标：根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。](#目标根据团队这次-sprint-所发布的版本评审相关的-backlog-中的问题检查是否已达到-sprint-的目标)
        - [5.1 会议准备](#51-会议准备)
        - [5.2 会议进程](#52-会议进程)
        - [5.3 会议结果](#53-会议结果)
      - [Sprint 回顾会议](#sprint-回顾会议)
        - [目标：通过总结以往的实践经验来提高团队生产力。](#目标通过总结以往的实践经验来提高团队生产力)
        - [注意：主要指导原则：不管我们现在发现了什么问题，我们必须懂得并坚信每个人通过他们当时所知的，他所拥有的技能和可得到的资源，在限定的环境下，都尽其所能做出了最好的成绩。](#注意主要指导原则不管我们现在发现了什么问题我们必须懂得并坚信每个人通过他们当时所知的他所拥有的技能和可得到的资源在限定的环境下都尽其所能做出了最好的成绩)
        - [6.1 会议准备](#61-会议准备)
        - [6.2 会议进程](#62-会议进程)
        - [6.3 会议结果](#63-会议结果)
    - [极限编程XP](#极限编程xp)
      - [极限编程是一个轻量级的、灵巧的软件开发方法；](#极限编程是一个轻量级的灵巧的软件开发方法)
        - [开发人员知道要做什么，以及要优先做什么；](#开发人员知道要做什么以及要优先做什么)
        - [工作有效率；](#工作有效率)
        - [有问题或困难时，能得到客户、同事、上级的回答或帮助；](#有问题或困难时能得到客户同事上级的回答或帮助)
        - [对工作做评估，并根据周围情况的变化及时重新评估；](#对工作做评估并根据周围情况的变化及时重新评估)
        - [积极承担工作，而不是消极接受分配；](#积极承担工作而不是消极接受分配)
        - [一周40小时工作制，不加班。](#一周40小时工作制不加班)
      - [与其他方法论相比，其最大的不同在于](#与其他方法论相比其最大的不同在于)
        - [在更短的周期内，更早地提供具体、持续的反馈信息。](#在更短的周期内更早地提供具体持续的反馈信息)
        - [在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。](#在迭代的进行计划编制首先在最开始迅速生成一个总体计划然后在整个项目开发过程中不断的发展它)
        - [依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。](#依赖于自动测试程序来监控开发进度并及早地捕获缺陷)
        - [依赖于口头交流、测试和源程序进行沟通。](#依赖于口头交流测试和源程序进行沟通)
        - [倡导持续的演化式设计。](#倡导持续的演化式设计)
        - [依赖于开发团队内部的紧密协作。](#依赖于开发团队内部的紧密协作)
        - [尽可能达到程序员短期利益和项目长期利益的平衡。](#尽可能达到程序员短期利益和项目长期利益的平衡)
      - [四大价值观](#四大价值观)
        - [XP的核心是其总结的沟通、简单、反馈、勇气四大价值观，它们是XP的基础，也是XP的灵魂。](#xp的核心是其总结的沟通简单反馈勇气四大价值观它们是xp的基础也是xp的灵魂)
        - [1. 沟通](#1-沟通)
        - [2. 简单](#2-简单)
        - [3. 反馈](#3-反馈)
        - [4. 勇气](#4-勇气)
        - [5. 四大价值观之外](#5-四大价值观之外)
        - [在这四大价值观之下，隐藏着一个更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间的相互关心、相互理解的基础之上。](#在这四大价值观之下隐藏着一个更深刻的东西那就是尊重因为这一切都建立在团队成员之间的相互关心相互理解的基础之上)
      - [5个原则](#5个原则)
        - [1. 快速反馈](#1-快速反馈)
        - [2. 简单性假设](#2-简单性假设)
        - [3. 逐步修改](#3-逐步修改)
        - [4. 提倡更改](#4-提倡更改)
        - [5. 优质工作](#5-优质工作)
      - [13个最佳实践](#13个最佳实践)
        - [在XP中，集成了13个最佳实践，有趣的是，它们没有一个是创新的概念，大多数概念和编程一样老。其主要创新点在于提供一种良好的思路，将这些最佳实践结合在一起，并且确保尽可能彻底地执行它们，使得它们能够在最大程度上相互支持，紧接下来，我们就对每一种最佳实践进行一番了解。](#在xp中集成了13个最佳实践有趣的是它们没有一个是创新的概念大多数概念和编程一样老其主要创新点在于提供一种良好的思路将这些最佳实践结合在一起并且确保尽可能彻底地执行它们使得它们能够在最大程度上相互支持紧接下来我们就对每一种最佳实践进行一番了解)
        - [1. 计划游戏](#1-计划游戏)
        - [2. 小型发布](#2-小型发布)
        - [3. 隐喻](#3-隐喻)
        - [4. 简单设计](#4-简单设计)
        - [5. 测试先行](#5-测试先行)
        - [6. 重构](#6-重构)
        - [7. 结对编程](#7-结对编程)
        - [8. 集体代码所有制](#8-集体代码所有制)
        - [9. 持续集成](#9-持续集成)
        - [10. 每周工作40小时](#10-每周工作40小时)
        - [11. 现场客户](#11-现场客户)
        - [12. 编码标准](#12-编码标准)
        - [13. 配合是关键](#13-配合是关键)
        - [有句经典名言“1+1\>2”最适合表达XP的观点，Kent Beck认为XP方法论的最大价值在于在项目中融会贯通地运用12个最佳实践，而非单独地使用。你当然可以使用其中的一些实践，但这并不意味着你就运用了XP方法论。XP方法论真正能够发挥其效能，就必须完整地运用12个实践。](#有句经典名言112最适合表达xp的观点kent-beck认为xp方法论的最大价值在于在项目中融会贯通地运用12个最佳实践而非单独地使用你当然可以使用其中的一些实践但这并不意味着你就运用了xp方法论xp方法论真正能够发挥其效能就必须完整地运用12个实践)
    - [水晶方法](#水晶方法)
      - [水晶方法，Crystal ，](#水晶方法crystal-)
      - [七大特征](#七大特征)
        - [体系特征一：经常交付](#体系特征一经常交付)
        - [体系特征二：反思改进](#体系特征二反思改进)
        - [体系特征三：渗透式交流](#体系特征三渗透式交流)
        - [体系特征四：个人安全](#体系特征四个人安全)
        - [体系特征五：焦点](#体系特征五焦点)
        - [体系特征六：与专家用户建立方便的联系](#体系特征六与专家用户建立方便的联系)
        - [体系特征七：配有自动测试、配置管理和经常集成功能的技术环境](#体系特征七配有自动测试配置管理和经常集成功能的技术环境)
    - [DSDM-动态系统开发方法](#dsdm-动态系统开发方法)
      - [Dynamic System Development Management，](#dynamic-system-development-management)
      - [基本原则](#基本原则)
        - [原则1：用户必须持续参与 active user involvement is imperative](#原则1用户必须持续参与-active-user-involvement-is-imperative)
        - [原则2：必须授予DSDM团队制定决策的权利 DSDM teams are empowered to make decisions including refining or changing requirements without the direct involvement of higher management](#原则2必须授予dsdm团队制定决策的权利-dsdm-teams-are-empowered-to-make-decisions-including-refining-or-changing-requirements-without-the-direct-involvement-of-higher-management)
        - [原则3：注重产品的经常交付 The focus is on frequent product delivery](#原则3注重产品的经常交付-the-focus-is-on-frequent-product-delivery)
        - [原则4：满足业务用户用途是接受交付品的主要依据 Fitness for purpose is the key criterion](#原则4满足业务用户用途是接受交付品的主要依据-fitness-for-purpose-is-the-key-criterion)
        - [原则5：迭代和增量式开发对得到正确的业务解决方案是必不可少的 Iterative and incremental development is necessary to converge on an accurate business solution](#原则5迭代和增量式开发对得到正确的业务解决方案是必不可少的-iterative-and-incremental-development-is-necessary-to-converge-on-an-accurate-business-solution)
        - [原则6：开发过程的所有变化可逆 All changes during development are reversible](#原则6开发过程的所有变化可逆-all-changes-during-development-are-reversible)
        - [原则7：在高层次上制定需求的基线 Requirements are initially agreed at a high level](#原则7在高层次上制定需求的基线-requirements-are-initially-agreed-at-a-high-level)
        - [原则8：测试自始至终贯穿于开发周期之中 Testing is integrated throughout the life cycle — this is essential with an incremental approach](#原则8测试自始至终贯穿于开发周期之中-testing-is-integrated-throughout-the-life-cycle--this-is-essential-with-an-incremental-approach)
        - [原则9：所有项目涉众间的通力合作是不可获缺的 A collaborative and co-operative approach between all stakeholders is essential](#原则9所有项目涉众间的通力合作是不可获缺的-a-collaborative-and-co-operative-approach-between-all-stakeholders-is-essential)
    - [测试驱动开发](#测试驱动开发)
      - [测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱动整个开发过程的进行。这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。](#测试驱动开发的基本思想就是在开发功能代码之前先编写测试代码然后只编写使测试通过的功能代码从而以测试来驱动整个开发过程的进行这有助于编写简洁可用和高质量的代码有很高的灵活性和健壮性能快速响应变化并加速开发过程)
      - [测试驱动开发的基本过程如下：](#测试驱动开发的基本过程如下)
        - [①　快速新增一个测试](#快速新增一个测试)
        - [②　运行所有的测试（有时候只需要运行一个或一部分），发现新增的测试不能通过](#运行所有的测试有时候只需要运行一个或一部分发现新增的测试不能通过)
        - [③　做一些小小的改动，尽快地让测试程序可运行，为此可以在程序中使用一些不合情理的方法](#做一些小小的改动尽快地让测试程序可运行为此可以在程序中使用一些不合情理的方法)
        - [④　运行所有的测试，并且全部通过](#运行所有的测试并且全部通过)
        - [⑤　重构代码，以消除重复设计，优化设计结构](#重构代码以消除重复设计优化设计结构)
      - [简单来说，就是不可运行/可运行/重构——这正是测试驱动开发的口号。](#简单来说就是不可运行可运行重构这正是测试驱动开发的口号)
        - [1) TDD根据客户需求编写测试用例，对功能的过程和接口都进行了设计，而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求。因为关注用户反馈，可以及时响应需求变更，同时因为从使用者角度出发的简单设计，也可以更快地适应变化。](#1-tdd根据客户需求编写测试用例对功能的过程和接口都进行了设计而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求因为关注用户反馈可以及时响应需求变更同时因为从使用者角度出发的简单设计也可以更快地适应变化)
        - [2) 出于易测试和测试独立性的要求，将促使我们实现松耦合的设计，并更多地依赖于接口而非具体的类，提高系统的可扩展性和抗变性。而且TDD明显地缩短了设计决策的反馈循环，使我们几秒或几分钟之内就能获得反馈。](#2-出于易测试和测试独立性的要求将促使我们实现松耦合的设计并更多地依赖于接口而非具体的类提高系统的可扩展性和抗变性而且tdd明显地缩短了设计决策的反馈循环使我们几秒或几分钟之内就能获得反馈)
        - [3) 将测试工作提到编码之前，并频繁地运行所有测试，可以尽量地避免和尽早地发现错误，极大地降低了后续测试及修复的成本，提高了代码的质量。在测试的保护下，不断重构代码，以消除重复设计，优化设计结构，提高了代码的重用性，从而提高了软件产品的质量。](#3-将测试工作提到编码之前并频繁地运行所有测试可以尽量地避免和尽早地发现错误极大地降低了后续测试及修复的成本提高了代码的质量在测试的保护下不断重构代码以消除重复设计优化设计结构提高了代码的重用性从而提高了软件产品的质量)
        - [4) TDD提供了持续的回归测试，使我们拥有重构的勇气，因为代码的改动导致系统其他部分产生任何异常，测试都会立刻通知我们。完整的测试会帮助我们持续地跟踪整个系统的状态，因此我们就不需要担心会产生什么不可预知的副作用了。](#4-tdd提供了持续的回归测试使我们拥有重构的勇气因为代码的改动导致系统其他部分产生任何异常测试都会立刻通知我们完整的测试会帮助我们持续地跟踪整个系统的状态因此我们就不需要担心会产生什么不可预知的副作用了)
        - [5) TDD所产生的单元测试代码就是最完美的开发者文档，它们展示了所有的API该如何使用以及是如何运作的，而且它们与工作代码保持同步，永远是最新的。](#5-tdd所产生的单元测试代码就是最完美的开发者文档它们展示了所有的api该如何使用以及是如何运作的而且它们与工作代码保持同步永远是最新的)
        - [6) TDD可以减轻压力、降低忧虑、提高我们对代码的信心、使我们拥有重构的勇气，这些都是快乐工作的重要前提。](#6-tdd可以减轻压力降低忧虑提高我们对代码的信心使我们拥有重构的勇气这些都是快乐工作的重要前提)
        - [7)快速的提高了开发效率。](#7快速的提高了开发效率)
      - [，](#)
    - [Lean软件开发（精益软件开发）](#lean软件开发精益软件开发)
      - [面对开发团队以及最终的产品大小的额外挑战，可以说软件开发是个持续学习的过程。最佳的改善软件开发环境的做法就是增强学习。在代码完成后马上进行测试可以避免缺陷的累积。不是去做成更多的文档或详细设计，而是对各种各样的想法进行实际的编码尝试。用户需求的收集过程可以简单地通过给最终客户演示，并听取他们的反馈来完成。](#面对开发团队以及最终的产品大小的额外挑战可以说软件开发是个持续学习的过程最佳的改善软件开发环境的做法就是增强学习在代码完成后马上进行测试可以避免缺陷的累积不是去做成更多的文档或详细设计而是对各种各样的想法进行实际的编码尝试用户需求的收集过程可以简单地通过给最终客户演示并听取他们的反馈来完成)
      - [使用短周期的迭代（每个迭代都应包括重构和集成测试）可以加速学习过程。在决定当前阶段的开发内容并对未来改善的努力方向进行调整时，在客户端帮助下通过简短的反馈会议来增强反馈。通过这些简短的反馈会议，客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案。从而，基于已开发出的原型，客户可以更好地理解自己的需求，开发者也能了解到如何才能更好地满足客户的需求。另一个关于和客户沟通、学习的想法是“基于组的开发”，这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案，因此通过和客户的对话加速了解决方案的产生。](#使用短周期的迭代每个迭代都应包括重构和集成测试可以加速学习过程在决定当前阶段的开发内容并对未来改善的努力方向进行调整时在客户端帮助下通过简短的反馈会议来增强反馈通过这些简短的反馈会议客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案从而基于已开发出的原型客户可以更好地理解自己的需求开发者也能了解到如何才能更好地满足客户的需求另一个关于和客户沟通学习的想法是基于组的开发这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案因此通过和客户的对话加速了解决方案的产生)
      - [原则](#原则)
        - [消除浪费](#消除浪费)
        - [增强学习](#增强学习)
        - [尽量延迟决定](#尽量延迟决定)
        - [尽快发布](#尽快发布)
        - [下放权力](#下放权力)
        - [嵌入质量](#嵌入质量)
        - [全局优化](#全局优化)
    - [轻量型RUP](#轻量型rup)
      - [RUP其实是个过程的框架，它可以包容许多不同类型的过程， Craig Larman 极力主张以敏捷型方式来使用RUP。](#rup其实是个过程的框架它可以包容许多不同类型的过程-craig-larman-极力主张以敏捷型方式来使用rup)
      - [RUP 是一种以架构为中心的开发过程，而这正是大、中型项目成功的关键。](#rup-是一种以架构为中心的开发过程而这正是大中型项目成功的关键)
      - [RUP（Rational Unified Process）是一个风险驱动的基于UML 和构件式架构的迭代递增型开发过程（框架）。RUP 定义了4 个阶段（起始、细化、构造、移交）和9 个科目（业务建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境）。这些阶段对应着关键里程碑的划分，而不同科目的工作流和活动 在生命周期的迭代中可以并发进行，具体执行的程度则可以调节。RUP 对于角色、流程、工件和活动的要求是灵活的、可配置的，所以它广泛地适用于各种类型和规模的项目。RUP 集中体现了6 个软件开发的最佳实践方法：迭代式开发、需求管理、构件式架构、基于UML 的可视化建模、持续校验质量、变更管理。](#ruprational-unified-process是一个风险驱动的基于uml-和构件式架构的迭代递增型开发过程框架rup-定义了4-个阶段起始细化构造移交和9-个科目业务建模需求分析和设计实现测试部署配置和变更管理项目管理环境这些阶段对应着关键里程碑的划分而不同科目的工作流和活动-在生命周期的迭代中可以并发进行具体执行的程度则可以调节rup-对于角色流程工件和活动的要求是灵活的可配置的所以它广泛地适用于各种类型和规模的项目rup-集中体现了6-个软件开发的最佳实践方法迭代式开发需求管理构件式架构基于uml-的可视化建模持续校验质量变更管理)
      - [RUP认为下面这些最佳实践可以改善软件的开发状况：](#rup认为下面这些最佳实践可以改善软件的开发状况)
        - [在早期迭代中解决高风险和高价值的问题](#在早期迭代中解决高风险和高价值的问题)
        - [不断的让用户参与评估、反馈和需求](#不断的让用户参与评估反馈和需求)
        - [在早期迭代中建立内聚的核心架构](#在早期迭代中建立内聚的核心架构)
        - [不断地验证质量：提早、经常和实际的测试](#不断地验证质量提早经常和实际的测试)
        - [可视化软件建模（使用UML）](#可视化软件建模使用uml)
        - [仔细的管理需求](#仔细的管理需求)
        - [实行变更请求和配置管理](#实行变更请求和配置管理)
      - [四个阶段](#四个阶段)
        - [初始阶段（Inception)：](#初始阶段inception)
        - [细化阶段（Elaboration）：](#细化阶段elaboration)
        - [构造阶段（Construction）：](#构造阶段construction)
        - [移交阶段（Transition）：](#移交阶段transition)
      - [多个流程](#多个流程)
        - [业务建模：在开发单独的应用时，业务建模包括领域对象建模。在从事大规模业务分析或业务过程再工程时，业务建模包括跨越整个企业的业务过程的动态建模。](#业务建模在开发单独的应用时业务建模包括领域对象建模在从事大规模业务分析或业务过程再工程时业务建模包括跨越整个企业的业务过程的动态建模)
        - [需求：对应用的需求分析，如写出用例和识别非功能性需求](#需求对应用的需求分析如写出用例和识别非功能性需求)
        - [分析和设计：设计的所有方面，包括总体架构、对象、数据库、网络连接等。分析强调的是对问题和需求的调查研究，而不是解决方案。设计强调的是满足需求的概念上的解决方案，而不是其实现。分析和设计可以被概括为：作正确的事（分析）和正确的做事（设计）。](#分析和设计设计的所有方面包括总体架构对象数据库网络连接等分析强调的是对问题和需求的调查研究而不是解决方案设计强调的是满足需求的概念上的解决方案而不是其实现分析和设计可以被概括为作正确的事分析和正确的做事设计)
        - [实现：编程和构建系统，而不是部署系统](#实现编程和构建系统而不是部署系统)
        - [测试](#测试-1)
        - [配置和变更管理](#配置和变更管理)
        - [项目管理](#项目管理)
        - [环境：指建立工具并为项目定制过程，也就是说，设置工具和过程环境。](#环境指建立工具并为项目定制过程也就是说设置工具和过程环境)
        - [1－5为核心工作流程，6－8为支持工作流程](#15为核心工作流程68为支持工作流程)
        - [The way of controlling](#the-way-of-controlling)
        - [The way of supporting](#the-way-of-supporting)
        - [The way of communicating](#the-way-of-communicating)
      - [模型和流程对应](#模型和流程对应)
        - [角色: the who](#角色-the-who)
        - [活动: the how](#活动-the-how)
        - [工件：the what](#工件the-what)
        - [工作流: the when](#工作流-the-when)
        - [规程（Disciplines）: 组合前面四种元素](#规程disciplines-组合前面四种元素)
      - [六大经验](#六大经验)
        - [迭代式开发。在软件开发的早期阶段就想完全、准确的捕获用户的需求几乎是不可能的。实际上，我们经常遇到的问题是需求在整个软件开发工程中经常会改变。迭代式开发允许在每次迭代过程中需求可能有变化，通过不断细化来加深对问题的理解。迭代式开发不仅可以降低项目的风险，而且每个迭代过程以可以执行版本结束，可以鼓舞开发人员。](#迭代式开发在软件开发的早期阶段就想完全准确的捕获用户的需求几乎是不可能的实际上我们经常遇到的问题是需求在整个软件开发工程中经常会改变迭代式开发允许在每次迭代过程中需求可能有变化通过不断细化来加深对问题的理解迭代式开发不仅可以降低项目的风险而且每个迭代过程以可以执行版本结束可以鼓舞开发人员)
        - [管理需求。确定系统的需求是一个连续的过程，开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求。RUP描述了如何提取、组织系统的功能和约束条件并将其文档化，用例和脚本的使用以被证明是捕获功能性需求的有效方法。](#管理需求确定系统的需求是一个连续的过程开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求rup描述了如何提取组织系统的功能和约束条件并将其文档化用例和脚本的使用以被证明是捕获功能性需求的有效方法)
        - [基于组件的体系结构。组件使重用成为可能，系统可以由组件组成。基于独立的、可替换的、模块化组件的体系结构有助于管理复杂性，提高重用率。RUP描述了如何设计一个有弹性的、能适应变化的、易于理解的、有助于重用的软件体系结构。](#基于组件的体系结构组件使重用成为可能系统可以由组件组成基于独立的可替换的模块化组件的体系结构有助于管理复杂性提高重用率rup描述了如何设计一个有弹性的能适应变化的易于理解的有助于重用的软件体系结构)
        - [可视化建模。RUP往往和UML联系在一起，对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力。RUP告诉我们如何可视化的对软件系统建模，获取有关体系结构于组件的结构和行为信息。](#可视化建模rup往往和uml联系在一起对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力rup告诉我们如何可视化的对软件系统建模获取有关体系结构于组件的结构和行为信息)
        - [验证软件质量。在RUP中软件质量评估不再是事后进行或单独小组进行的分离活动，而是内建于过程中的所有活动，这样可以及早发现软件中的缺陷。](#验证软件质量在rup中软件质量评估不再是事后进行或单独小组进行的分离活动而是内建于过程中的所有活动这样可以及早发现软件中的缺陷)
        - [控制软件变更。迭代式开发中如果没有严格的控制和协调，整个软件开发过程很快就陷入混乱之中，RUP描述了如何控制、跟踪、监控、修改以确保成功的迭代开发。RUP通过软件开发过程中的制品，隔离来自其他工作空间的变更，以此为每个开发人员建立安全的工作空间。](#控制软件变更迭代式开发中如果没有严格的控制和协调整个软件开发过程很快就陷入混乱之中rup描述了如何控制跟踪监控修改以确保成功的迭代开发rup通过软件开发过程中的制品隔离来自其他工作空间的变更以此为每个开发人员建立安全的工作空间)
      - [核心概念](#核心概念)
        - [角色：描述某个人或者一个小组的行为与职责。RUP预先定义了很多角色。](#角色描述某个人或者一个小组的行为与职责rup预先定义了很多角色)
        - [活动：是一个有明确目的的独立工作单元。](#活动是一个有明确目的的独立工作单元)
        - [工件：是活动生成、创建或修改的一段信息。](#工件是活动生成创建或修改的一段信息)
      - [RUP裁剪](#rup裁剪)
        - [RUP是一个通用的过程模板，包含了很多开发指南、制品、开发过程所涉及到的角色说明，由于它非常庞大所以对具体的开发机构和项目，用RUP时还要做裁剪，也就是要对RUP进行配置。RUP就像一个元过程，通过对RUP进行裁剪可以得到很多不同的开发过程，这些软件开发过程可以看作RUP的具体实例。RUP裁剪可以分为以下几步：](#rup是一个通用的过程模板包含了很多开发指南制品开发过程所涉及到的角色说明由于它非常庞大所以对具体的开发机构和项目用rup时还要做裁剪也就是要对rup进行配置rup就像一个元过程通过对rup进行裁剪可以得到很多不同的开发过程这些软件开发过程可以看作rup的具体实例rup裁剪可以分为以下几步)
        - [1)        确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。](#1--------确定本项目需要哪些工作流rup的9个核心工作流并不总是需要的可以取舍)
        - [2)        确定每个工作流需要哪些制品。](#2--------确定每个工作流需要哪些制品)
        - [3)        确定4个阶段之间如何演进。确定阶段间演进要以风险控制为原则，决定每个阶段要那些工作流，每个工作流执行到什么程度，制品有那些，每个制品完成到什么程度。](#3--------确定4个阶段之间如何演进确定阶段间演进要以风险控制为原则决定每个阶段要那些工作流每个工作流执行到什么程度制品有那些每个制品完成到什么程度)
        - [4)        确定每个阶段内的迭代计划。规划RUP的4个阶段中每次迭代开发的内容。](#4--------确定每个阶段内的迭代计划规划rup的4个阶段中每次迭代开发的内容)
        - [5)        规划工作流内部结构。工作流涉及角色、活动及制品，他的复杂程度与项目规模即角色多少有关。最后规划工作流的内部结构，通常用活动图的形式给出。](#5--------规划工作流内部结构工作流涉及角色活动及制品他的复杂程度与项目规模即角色多少有关最后规划工作流的内部结构通常用活动图的形式给出)
- [面向对象](#面向对象)
  - [结构化与面向对象方法特点比较](#结构化与面向对象方法特点比较)
  - [OOD(Object Oriented Design)](#oodobject-oriented-design)
    - [OOD步骤](#ood步骤)
    - [OOD设计过程中要展开的主要几项工作](#ood设计过程中要展开的主要几项工作)
      - [（一）对象定义规格的求精过程](#一对象定义规格的求精过程)
      - [（二）数据模型和数据库设计](#二数据模型和数据库设计)
      - [（三）优化](#三优化)
      - [六、OO方法的特点和面临的问题](#六oo方法的特点和面临的问题)
    - [实现UML建模](#实现uml建模)
      - [(1)  业务对象的提取](#1--业务对象的提取)
      - [(2)  根据SRS、CRC等实现用况建模](#2--根据srscrc等实现用况建模)
      - [(3)  实现业务顺序图](#3--实现业务顺序图)
      - [(4)  建立类图，根据用况图建立对象之间的关联](#4--建立类图根据用况图建立对象之间的关联)
      - [(5)  绘制活动图、实现协作图、状态图](#5--绘制活动图实现协作图状态图)
  - [OOP(Object Oriented Programming)](#oopobject-oriented-programming)
  - [OOA(Object Oriented Analyzing)](#ooaobject-oriented-analyzing)
    - [需要做什么](#需要做什么)
    - [怎么做](#怎么做)
    - [主要原则](#主要原则)
      - [（1）抽象](#1抽象)
      - [（2）封装](#2封装)
      - [（3）继承](#3继承)
      - [（4）分类](#4分类)
      - [（5）聚合](#5聚合)
      - [（6）关联](#6关联)
      - [（7）消息通信](#7消息通信)
      - [（8）粒度控制](#8粒度控制)
      - [（9）行为分析](#9行为分析)
    - [三种分析模型](#三种分析模型)
      - [1、对象模型](#1对象模型)
      - [2、动态模型](#2动态模型)
      - [3、功能模型(即用例模型作为输入)。](#3功能模型即用例模型作为输入)
    - [OOA主要优点](#ooa主要优点)
    - [基本步骤](#基本步骤)
      - [第一步，确定对象和类。](#第一步确定对象和类)
      - [第二步，确定结构（structure）。](#第二步确定结构structure)
      - [第三步，确定主题（subject）。](#第三步确定主题subject)
      - [第四步，确定属性（attribute）。](#第四步确定属性attribute)
      - [第五步，确定方法（method）。](#第五步确定方法method)
    - [面向对象](#面向对象-1)
      - [第一步是抽取建立领域的概念模型](#第一步是抽取建立领域的概念模型)
      - [第二步是构建完善系统结构：](#第二步是构建完善系统结构)
      - [第三步是利用“4＋1”视图描述系统架构](#第三步是利用41视图描述系统架构)
      - [第四步是性能优化](#第四步是性能优化)
  - [基本](#基本)
    - [类](#类)
      - [抽象类](#抽象类)
        - [抽象类的特点：](#抽象类的特点)
        - [对比父类中的虚方法(virtual)和抽象方法(abstract)的区别：](#对比父类中的虚方法virtual和抽象方法abstract的区别)
      - [属性](#属性)
      - [方法](#方法)
    - [对象](#对象)
    - [接口](#接口)
    - [关系](#关系)
      - [依赖（Dependency）：](#依赖dependency)
      - [关联（Association）：](#关联association)
      - [链接（link）：](#链接link)
      - [聚合（Aggregation）：](#聚合aggregation)
      - [组合关系（Composition）：](#组合关系composition)
      - [泛化（Generalization）：](#泛化generalization)
      - [实现（Realization）：](#实现realization)
      - [符号](#符号)
    - [面向对象的三大特征](#面向对象的三大特征)
      - [(1). 封装](#1-封装)
      - [(2). 继承](#2-继承)
      - [(3). 多态](#3-多态)
    - [抽象类和接口的比较](#抽象类和接口的比较)
  - [其他问题](#其他问题)
    - [面向对象与面向过程区别](#面向对象与面向过程区别)
  - [面向对象设计原则](#面向对象设计原则)
    - [1、单一职责原则 SRP](#1单一职责原则-srp)
    - [2、开闭原则 OCP](#2开闭原则-ocp)
    - [3、里氏代换原则 LSP](#3里氏代换原则-lsp)
    - [4、依赖倒转原则 DIP](#4依赖倒转原则-dip)
    - [5、接口隔离原则 ISP](#5接口隔离原则-isp)
    - [6、合成复用原则 CRP](#6合成复用原则-crp)
    - [7、迪米特法则（最少知道原则）DP](#7迪米特法则最少知道原则dp)
  - [Gof设计模式](#gof设计模式)
    - [行为型](#行为型)
      - [Iterator（迭代器模式）](#iterator迭代器模式)
      - [Interpreter（解析器模式）](#interpreter解析器模式)
      - [Observer（观察者模式）](#observer观察者模式)
      - [Mediator（中介者模式）](#mediator中介者模式)
      - [Visitor（访问者模式）](#visitor访问者模式)
      - [Memento（备忘录模式）](#memento备忘录模式)
      - [State（状态模式）](#state状态模式)
      - [Strategy（策略模式）](#strategy策略模式)
      - [Template Method（模板方法模式）](#template-method模板方法模式)
      - [Command（命令模式）](#command命令模式)
      - [Chain of Responsibility（职责链模式）](#chain-of-responsibility职责链模式)
    - [创建型](#创建型)
      - [Singleton（单例模式）](#singleton单例模式)
      - [Prototype（原型模式）](#prototype原型模式)
      - [Builder（建造者模式）](#builder建造者模式)
      - [Factory Method(工厂模式)](#factory-method工厂模式)
      - [ Abstract Factory（抽象工厂模式）](#abstract-factory抽象工厂模式)
    - [结构型](#结构型)
      - [Bridge（桥接模式）](#bridge桥接模式)
      - [Facade（外观模式）](#facade外观模式)
      - [Composite(组合模式)](#composite组合模式)
      - [Decorator(装饰模式)：](#decorator装饰模式)
      - [Adapter（适配器模式）](#adapter适配器模式)
      - [Proxy（代理模式）](#proxy代理模式)
      - [Flyweight（享元模式）](#flyweight享元模式)
    - [模式之间关系](#模式之间关系)
    - [其他](#其他)
    - [参考资料](#参考资料)
      - [23种设计模式UML图](#23种设计模式uml图)
  - [UML](#uml)
    - [组成](#组成)
    - [架构视图分类](#架构视图分类)
    - [UML视图](#uml视图)
      - [(1) 用例图(Use Case Diagram)，描述系统功能；](#1-用例图use-case-diagram描述系统功能)
      - [(2) 类图(Class Diagram)，描述系统的静态结构；](#2-类图class-diagram描述系统的静态结构)
        - [基本元素符号：](#基本元素符号)
        - [关　系：](#关系-1)
      - [(3) 对象图(Object Diagram)，描述系统在某个时刻的静态结构；](#3-对象图object-diagram描述系统在某个时刻的静态结构)
      - [(4) 组件图(Component Diagram)，描述了实现系统的元素的组织；](#4-组件图component-diagram描述了实现系统的元素的组织)
      - [(5) 配置图(Deployment Diagram)，描述了环境元素的配置，并把实现系统的元素映射到配置上；](#5-配置图deployment-diagram描述了环境元素的配置并把实现系统的元素映射到配置上)
      - [(6) 状态图(State Diagram)，描述了系统元素的状态条件和响应；](#6-状态图state-diagram描述了系统元素的状态条件和响应)
      - [(7) 时序图(Sequence Diagram)，按时间顺序描述系统元素间的交互；](#7-时序图sequence-diagram按时间顺序描述系统元素间的交互)
      - [(8) 协作图(Collaboration Diagram)，按照时间和空间顺序描述系统元素间的交互和它们之间的关系；](#8-协作图collaboration-diagram按照时间和空间顺序描述系统元素间的交互和它们之间的关系)
      - [(9) 活动图(Activity Diagram)，描述了系统元素的活动；](#9-活动图activity-diagram描述了系统元素的活动)
      - [Other](#other)
        - [包图](#包图)
        - [组合结构图](#组合结构图)
        - [轮廓图](#轮廓图)
        - [序列图](#序列图)
        - [通訊圖](#通訊圖)
        - [交互概览图](#交互概览图)
        - [时序图](#时序图)
        - [内部结构图](#内部结构图)
        - [协作使用图](#协作使用图)
        - [表现图](#表现图)
        - [网络体系结构图](#网络体系结构图)
        - [配置文件图](#配置文件图)
        - [信息流程图](#信息流程图)
        - [行为状态机图](#行为状态机图)
        - [协议状态机图](#协议状态机图)
        - [交互图](#交互图)
    - [分类](#分类)
      - [不同架构视图的应用](#不同架构视图的应用)
        - [(1) 用户模型视图](#1-用户模型视图)
        - [(2) 结构模型视图](#2-结构模型视图)
        - [(3) 行为模型视图](#3-行为模型视图)
        - [(4) 实现模型视图](#4-实现模型视图)
        - [(5) 环境模型视图](#5-环境模型视图)
      - [静态结构还是动态行为](#静态结构还是动态行为)
        - [静态结构](#静态结构)
        - [动态行为](#动态行为)
    - [4+1视图与UML视图对应](#41视图与uml视图对应)
  - [词汇表和术语](#词汇表和术语)
- [ 微服务](#-微服务)
- [DDD](#ddd)
  - [微服务和DDD的渊源](#微服务和ddd的渊源)
    - [**为什么DDD适合微服务**](#为什么ddd适合微服务)
    - [DDD与微服务的关系](#ddd与微服务的关系)
  - [关键概念](#关键概念)
    - [领域和子域Domain](#领域和子域domain)
    - [核心域，通用域和支撑域](#核心域通用域和支撑域)
    - [通用语言](#通用语言)
    - [限界上下文BoundedContext](#限界上下文boundedcontext)
    - [**实体Entity**](#实体entity)
  - [贫血模型（Anemia Model）和充血模型（Congestion Model）](#贫血模型anemia-model和充血模型congestion-model)
    - [**值对象ValueObject**](#值对象valueobject)
  - [聚合根AggregateRoot](#聚合根aggregateroot)
  - [聚合Aggregate](#聚合aggregate)
    - [领域事件](#领域事件)
    - [事件风暴](#事件风暴)
    - [分层架构](#分层架构)
    - [代码架构](#代码架构)
    - [**COLA4.0**](#cola40)
- [DDD实战](#ddd实战)
  - [战略设计](#战略设计)
    - [产品愿景](#产品愿景)
    - [场景分析](#场景分析)
    - [领域建模](#领域建模-1)
    - [通用语言](#通用语言-1)
    - [微服务拆分](#微服务拆分)
  - [战术设计](#战术设计)
  - [详细设计](#详细设计)
- [低代码平台](#低代码平台)
  - [Microsoft Platform](#microsoft-platform)
- [OPS](#ops)

# 软件架构模式的演进

![](https://pic4.zhimg.com/80/v2-f91eb131f070844e04108070099dbf4f_720w.webp)

我们先来分析一下软件架构模式演进的三个阶段。

第一阶段是单机架构：\*\*采用面向过程的设计方法，系统包括客户端UI层和数据库两层，采用C/S架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。

第二阶段是集中式架构：\*\*采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的SOA架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。

第三阶段是分布式微服务架构：\*\*随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。

在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。很容易导致需求、设计与代码实现的不一致，往往到了软件上线后，我们才发现很多功能并不是自己想要的，或者做出来的功能跟自己提出的需求偏差太大

# 开发模式

## ATDD：验收测试驱动开发

（Acceptance Test Driven Development）

> 通过单元测试用例来驱动功能代码的实现，团队需要定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的TDD实践和测试人员的测试脚本开发。面向开发人员，强调如何实现系统以及如何检验。

#### 什么是ATDD\#

> 首先，ATDD不是一种测试方法论，而是一种开发方法论。

> UTDD涉及的人员仅仅是开发人员，那么ATDD仅仅涉及测试人员吗？不是，产品、开发、测试都需要参与到ATDD中来。

> 在ATDD活动中团队需要就需求定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动产品的代码开发和测试脚本开发。

> ATDD一定是基于测试自动化和持续集成的。

#### ATDD工具

> 1.  Fit

> 1.  Fitnesse

> 1.  Exactor

> 1.  TextTest

> 1.  jWebUnit中提供的夹具

##### Selenium

##### Robot Framework

> Robot Framework（RF）是用于验收测试和验收测试驱动开发（ATDD）的自动化测试框架。 基于 Python 编写，但也可以在 Jython（Java）和 IronPython（.NET） 上运行，提供跨平台支持（Windows、Linux 或 MacOS ）。

#### ATDD的基本流程\#

> 和TDD的“红-绿-重构”类似，ATDD的流程也是类似的思路。

##### 讨论澄清阶段

> 全组参与的针对需求和方案的讨论

> 大家产出对需求和方案共同的理解

> 通过明确验收测试方式澄清我们的实现方案

> 验收测试方式将被自动化

##### 开发阶段

> 用明确具体的验收测试方式来指导开发工作

> 验收测试的自动化和特性的开发可以并行开展

> 全组成员对验收测试的自动化负责，而不仅仅是测试人员

> 最终，我们的产品实现能让所有的自动化测试通过

##### 交付阶段

> 我们要保证之前迭代所有的自动化验收测试能在新交付上通过

> 给所有利益相关者演示我们的新特性

> 收集反馈，讨论改进

#### ATDD的好处\#

#### ATDD自动化测试框架

## DDD：领域驱动开发

（Domain Drive Design）

也就是领域驱动开发,DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现,将分析和设计结合起来，不再使他们处于分裂的状态，建立一个具有业务伸缩性的模型。

#### 概念

> 实体（Entity）

> 值对象（Value Object）

> 服务（Service）

> 聚合（Aggregate）

> 聚合根（Aggregate Root）

> 工厂（Factory）

> 仓储（Repository）

#### 领域建模

> 实体、

> 值对象

> 服务

#### 生命周期

> 工厂

> 仓储

#### 软件系统架构风格

> 比较传统的常见的分层方式就是分三层：界面层、业务逻辑层以及数据访问层，各层之间会有数据传输对象（DTO）完成数据交互，以此隔离不同层内部的实现细节。领域驱动设计则将应用系统分为四层：用户界面层、应用层、领域层和基础设施层：

##### 经典分层架构（N-Tier Architecture）

> 用户界面层

> > 就是直接面向用户的前端应用。如果系统仅提供API，那么API这一层也属于用户界面层。

> 应用层

> > 它主要负责协调下层的执行任务，并隔离领域层与用户界面层。它们不参与任何领域或者业务相关的操作，仅仅负责协调。最常见的一种实现就是在应用层引入事务处理，有时候甚至还会跨资源实现分布式事务

> 领域层

> > 你的领域模型所涉及的所有对象都会出现在这一层，领域层对象需要尽量避免贫血模型，开发团队与领域专家一起完成领域层的设计与开发任务

> 基础设施层

> > 所有与技术细节相关的基础设施组件都属于这一层，此外还有面向切面（Aspect-Oriented）的组件，比如异常处理模块、缓存模块、安全模块等等，也都属于基础设施层

##### 事件驱动型架构（Event-Driven Architecture）

##### 微服务架构（Microservices Architecture）

> 在微服务架构中，各应用服务之间互相独立，它们可以由不同团队采用异构的平台和技术，这些服务可以使用不同的数据存储系统，甚至可以是一个仅进行数据实时处理而不存储任何数据的计算服务，微服务实例之间可以以同步或者异步的方式进行通讯。

## TDD(UTDD)：测试驱动开发

> （Test-Driven Development）

> TDD核心可看做一个闭环：RED -> GREEN -> REFACTOR，即运行一个失败的测试 -> 让测试通过 -> 及时重构代码。

#### 测试驱动开发是敏捷开发中的一项核心实践和技术，

> 也是一种设计方法论，TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。

#### TDD流程

> 写一个测试用例

> 运行测试

> 写刚好能让测试通过的实现

> 运行测试

> 识别坏味道，用手法修改代码

> 运行测试

#### TDD 的三条规则

> 除非是为了使一个失败的 unit test 通过，否则不允许修改任何产品代码

> 在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）

> 只允许编写刚好能够使一个失败的 unit test 通过的产品代码

#### 好的单元测试应该符合几条原则：

> 简单，只测试一个需求

> 符合 Given-When-Then 格式

> 速度快

> 包含断言

> 可以重复执行

#### TDD 编码方式

> 先分解任务，分离关注点（后面有演示）

> 列 Example，用实例化需求，澄清需求细节

> 写测试，只关注需求，程序的输入输出，不关心中间过程

> 写实现，不考虑别的需求，用最简单的方式满足当前这个小需求即可

> 重构，用手法消除代码里的坏味道

> 写完，手动测试一下，基本没什么问题，有问题补个用例，修复

> 转测试，小问题，补用例，修复

> 代码整洁且用例齐全，信心满满地提交

#### TDD（测试驱动开发）相关测试框架

> XUnit：相应于各语言的测试框架

> EasyMock：模拟接口或类行为

> DBUnit：数据库测试

> Spring-test：提供数据库集成测试

> 基于请求的web作测试

> > （1）Spring-mock：可以mock浏览器请求等

> > （2）JspTest：测试jsp页面

> 基于控件的web作测试

> > （1）WicketTester

> > （2）Apache Shale

> Apache commons VFS：虚拟文件系统，对文件系统进行模拟

> HttpUnit：http测试

> Jemmy和Abbot：测试驱动开发Swing

> H sqldb：内存数据库，模拟真实数据库

> Dbdeploy：数据库结构的增量变动

> GSBase：equals和hashcode测试

> BeanInject：可以将测试替身强行赋给某个类的私有变量

> JFCUnit：JFC类测试

> ConTest：Java并发单元测试

> XMLUnit：测试xml结构及内容

> JUnitPerf：性能测试

#### 测试驱动开发的基本过程

> 1） 明确当前要完成的功能。可以记录成一个 TODO 列表。 

> 2） 快速完成针对此功能的测试用例编写。 

> 3） 测试代码编译不通过。

> 4） 编写对应的功能代码。

> 5） 测试通过。 

> 6） 对代码进行重构，并保证测试通过。

> 7） 循环完成所有功能的开发。

#### 测试驱动开发的原则

> 1）测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。

> 2）一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。

> 3）测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。

> 4）测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。

> 5）先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。

> 6）可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。

## BDD：行为驱动开发

> （Behavior Driven Development）

# 架构设计

> 《软件架构设计说明书》

### 定义

定义 1：软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。
定义 2：软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。
定义 3：软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000） 前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件” 更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。

#### 说明

为了更好地理解软件架构的定义，特作如下说明：
（1）	架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的
“外部可见”属性。
（2）	架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。
（3）	任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。
（4）	元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。
（5）	架构具有“基础”性：它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。
（6）	架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。

#### 影响因素

（1）	影响架构的因素。软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。
这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。
（2）	架构对上述诸因素具有反作用，例如，影响开发组织的结构。架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。

### 开发质量属性

> 运行期

> 性能

> 安全

> 易用

> 可伸缩

> 互操作

> 可靠

> 持续可用

> 鲁棒

在有些非正常情况下仍然能用

#### 开发期

> 易理解性

> 可扩展性

> 可重用性

> 可测试性

> 可维护性

> 可移植性

### 模型

> 结构模型

> 框架模型

> 动态模型

> 过程模型

> 功能模型

### 4+1视图

> 逻辑视图

> 进程视图

> 物理视图

> 场景视图

## 概设

> 把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。生成《软件概要设计说明书》。

## 详设

> 依据概要设计阶段的分解，设计每个模块内的算法、流程等。《软件详细设计说明书》

## 编码

> 代码

## 测试

> 黑盒

> 白盒

## 验收

> 《验收报告》

# 系统架构

> 定义 1：软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。

> 定义 2：软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。

> 定义 3：软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）

> 前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件” 更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。

> > （1）	架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。

> > （2）	架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。

> > （3）	任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。

> > （4）	元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。

> > （5）	架构具有“基础”性：它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。

> > （6）	架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。

## 模型

### 结构模型

### 框架模型

### 动态模型

### 过程模型

### 功能模型

## 4+1视图

### 逻辑视图

### 进程视图

### 物理视图

### 场景视图

## 开发质量属性

### 运行期

#### 性能

#### 安全

#### 易用

#### 可伸缩

#### 互操作

#### 可靠

#### 持续可用

#### 鲁棒

在有些非正常情况下仍然能用

### 开发期

#### 易理解性

#### 可扩展性

#### 可重用性

#### 可测试性

#### 可维护性

#### 可移植性

## 企业架构成熟度模型（EAMM）

### EAMM从以下几个方面来对不同级别进行描述:

#### Administration – 治理角色与职责

#### Planning – 企业架构开发路标以及实现计划

#### Framework – 流程和模板

#### Blueprint – 实际的标准和规范集合

#### Communication – 交流与发布EA和详细蓝图

#### Compliance（一致性） – 遵循发布的标准、流程和其它EA元素，文档化流程并且能够跟踪变化

#### Integration – touch-points of management processes to the EA

#### Involvement – 整个组织对EA的支持

### 分级

#### EA LEVEL 0 - NO PROGRAM

> 没有文档化的架构框架，虽然解决方案已经开发并实现了，但是并没有公认的标准和最佳实践的指导，组织完全依赖于独立个人贡献者的知识。

#### EA LEVEL 1 - INFORMAL PROGRAM

> 定义了基本的企业架构和标准。大家对这些步骤达成基本一致，但是并不一定会遵守并执行，基本上是在非正式的情况下使用。这个状态下组织仍旧依赖于独立个人贡献者的知识。

#### EA LEVEL 2 - REPEATABLE PROGRAM

> 基本架构和标准已经制定并跟踪验证，开发时作为可重用方法，产品和组件遵守标准，需求得到一致认同，对流程绩效也进行了度量。

## 软件分层

### 分层原则

> 1.每一层都应该都是由类或组件组成。

> 2.只存在上层对下层的依赖，下层不依赖于上层。

> 3.上层调用下层的api，下层实现细节的变动不会影响到上层的代码。

### 框架模型

> 1.可伸缩性：可以把每一层分布在不同机器上，实现分布式应用。

> 2.可维护性：如果需求变动，只要相应调整某一层的实现即可。

> 3.可管理性：分层有利用分工。

> 4.可扩展性：增加功能只需要在相应层上调整即可。

> 5.可重要性：业务逻辑模块则可供系统的多个模块公共。

## 微服务

## consul

## 自动化测试

四、常见的自动化测试框架

1、接口自动化框架：

①、java+testNG/Junit+Maven/Ant/Gradle+Jenkins+MySQL+testlink/redmine

②、python+unittest/pytest+Git+Jenkins+MySQL+testlink/redmine

③、python+rebot framework+unittest/pytest+Git+Jenkins+MySQL+testlink/redmine

④、jmeter+Maven/Ant+Jenkins+MySQL+testlink/redmine

2、UI自动化测试框架

①、java+selenium/appium+testNG/Junit+Maven/Ant/Gradle+Jenkins+MySQL+testlink/redmine

②、python+selenium/appium+unittest/pytest+Git+Jenkins+MySQL+testlink/redmine

③、python+rebot framework+unittest/pytest+Git+Jenkins+MySQL+testlink/redmine

# 敏捷开发

## 敏捷软件开发宣言

### 个人与交互 高于 流程和工具

### 可用软件 高于 详尽的文档

### 客户合作 高于 合同谈判

### 响应变化 高于 遵循计划

## 敏捷宣言的十二条原则

### 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。

### 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。

### 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。

### 业务人员和开发人员必须相互合作，项目中的每一天都不例外。

### 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。

### 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。

### 可工作的软件是进度的首要度量标准。

### 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。

### 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。

### 以简洁为本，它是极力减少不必要工作量的艺术。

### 最好的架构、需求和设计出自自组织团队。

### 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

## 应该着重注意的点

### 需求在开发中的重要性

#### 大量的开发过程告诉我，需求在软件开发过程中是极其重要的。传统的开发强调初期的需求调研及需要分析，这个过程对于一些正规的团队会产生大量的文档，而后交由开发展开产品生产。

#### 然而，事实却不是想象这么简单，无数的例子说明了一点，仅仅在需求调研过程中了解到的需求是无法保证的。数不清的例子告诉我们，需求是会变的，变的原因很多。在极端的情况下，有些客户签字的需求在开发完后，有需要变更也很正常。

#### 所以需求是影响软件开发的第一重要因素，需求来源于业务，我们开发的产品不就是因为这些业务才去做的吗？如何需求都无法把握好，还谈什么开发出好用的产品？

#### 然而如何做好需求呢？我想首先要确立需求的地位，然后只有通过不断的沟通、尝试、反馈向真实需求迈进。

### 强调人与人的交流

#### 不管怎么样开发过程中主要还是靠人的，而且软件开发是个复杂的团体工程，一个小些的产品也会涉及到各类人：客户、业务分析、管理人员、程序员、测试员等等。这么多人在一起做事情，有一方没有处理好结果肯定就会有问题。

#### 有这样一个例子：客户提出了一个会员管理功能需求，需求人员了解后组织了解决方案，于是交付了开发实现。而经过二个月无尽的黑夜之后交付，需求一看有个模块做的有偏差，但是已经来不及修改了。交给客户看后，发现这不是他们要的会员管理功能相差较大，另外在功能开发的这一段时间，客户又有了新想法，要对原先需求做调整。

#### 这种例子可能大家经常经历吧？

#### 这种问题在敏捷开发方法中提出了解决方法，就是通过不断的交付可用的制品。看起来很抽象，其实很简单。同样是上面的例子：

#### Ø 客户提出会员管理功能需求

#### Ø 需求人员在了解需求后与开发负责人商量，确定一个快迭代的开发计划，每二周向客户演示一次，并将这个计划与客户确认

#### Ø 确认后需求人员向全体成员讲解需求背景故事

#### Ø 开发负责人组织并确定迭代计划内容，明确每个迭代提交的产品目标、开发任务安排、测试跟踪计划

#### Ø 每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏

#### Ø 后面就是每二周向客户演示一次产品，并获得客户的反馈

#### Ø 根据客户的反馈调整下个迭代计划，并继续下一个迭代

#### Ø 直到产品交付

#### 通过上面的步骤，就不至于在开发完成后才知道用户的真实想法，因为很多用户对软件开发是没有概念的，他只知道自己有某种需求，但最开始是没有一个完整的概念的。所以就要通过不断的让用户看到产品的模型，这个过程用户才会逐步的对产品产生概念。同样的在过程中客户的提出需求变更也是在一定的可控制范围之内，这样一来可以大大的减少软件返工的情况，自然就不会拖延计划了。

#### 而这个过程中，需求已经完成了一个真正的过渡，不再是一头重的情况了。他让需求从客户那快速的反馈到开发团队中。同样的，在开发不断的交付制品时，需求也更加及时的了解到产品的进度，把握开发人员开发的功能是否符合需求。

#### 当然这并不是一个标准做法，不同的团队可以有不同的处理方式。这里只是想强调需求需要更多的投入到开发过程中去，及时的与客户沟通交流，了解到客户的真实想法。

### 强调文档的作用

#### 我觉得很多对敏捷开发的一个误解就是不需要文档，敏捷开发并未抛弃文档。只是更强调更有效的方式使用文档。在很多传统开发方法中，特别是很多很正规的开发团队对文档的要求非常苛刻。然而事实是文档不易管理，最痛苦的是不好维护，文档需要随着变化而变化，比如需求调整、技术架构升级、产品维护等等。如果要保证文档的一致性，太难了。特别是对于一些无法进行有效管理的开发团队就更加明显，经常是软件已经几个版本了，文档却是两年前的。

#### 但敏捷真的不需要文档吗？我想不是的，如何把文档做到好维护我想才是最重要的。文档到底指的指的什么？什么样的算文档？

#### 提出上面两个问题，我们先想想经常说的文档的作用是什么？不就是一个传播工具吗？可以用作记录、给他人看、用于以后查看。有很多方法可就解决了这个问题，比如wiki系统。维护一个wiki系统，可以随时写，随时维护，可以方便的查找。嗯，多方便。

#### 另外一个问题就是什么样的工作需要形成文档呢？

#### 记得在前一家公司，维护一个10多年的老系统修改一个公式计算的BUG，但是怎么也不知道这个复杂的公式是什么意思，问过了公司大部分的人也无人可解。这时想，如果当初有那么一份文档，谢天谢地。

#### 像这种关键的内容有份文档还是很重要的，否则随着时间推移，谁也不能保证能记得住当时为什么会这么干。

#### 记得多年前一次记笔记的经历，我看了一篇文章了解了DELPHI实现单实例模式的方法，这种方法很酷。于是整理成了笔记写在了wiki上，第二天就得到了回复，帮助到了别外产品开发组的同事。

#### 嗯，文档就是这样他具有传播性，你不可能跑去跟所有人说出你的想法，但是文档却更容易达成。他也有传承性，有些文档也许10多年后又起了重要作用。

### 团队协作

#### 1、减少对开发人员的干扰

#### 曾经接手一个产品的开发，最初遇到一个很头痛的问题，原先写好的迭代计划，而且工作量也较大，大家都在忙着。即便在这样的状态下，客服人员却经常跑来找某个程序员A维护各种系统问题，程序员A在一次维护中竟然导致了系统数据出现大面积错误。程序员A心理上承受着巨大的压力，而每天的这些问题又不得不解决，加之新版本又有很重的开发任务无法完成，最终导致整个开发计划变更。

#### 我无法再忍受，找到了需求及客服的负责人，沟通后发现这些问题很多都是重复性的，主要是因为原先系统的不足。于是回去组织人员做了几个后台临时功能，并交付给了客服人员，之后就没有再来找过这位程序员A。后续我又找到了客服负责人，要求不能直接找开发人员解决这类问题，并与负责人约定了处理过程。

#### 这是个例子，在实际情况中还有很多这种事情，甚至有很多开发人员要直接面对客户。我想对于职能型团队来说，开发团队最好是减少这些方面的干忧。当然对于一个人包干的情况就不讨论了。

#### 大部分的人都不是超人，在一个时间段内处理超出自己负荷的工作是很难做好保质保量的。所以对于开发管理人员一定要考虑到这点，尽量让开发人员有比较好的工作进度环境，通过外界的方式来解决一些开发团队的干扰。

#### 我接触过的很多程序员都很反感这种干扰，虽然有些人在这种全面的工作强度下成长很快，但是并非所有人都适应，长期下来会有怨恨和不快，工作效率会下降。心情舒畅还是很重要的，记得有一次迭代总结时，有个程序员总结说：发现心情舒畅自己的工作效率很高。呵呵。我想你也有同感吧。

#### 2、不要忽略测试人员在开发阶段的作用

#### 曾经多少次在项目发布前加班到深夜2点的情景还历历在目，那种感觉即快乐又痛苦。由于和客户签定的合同的交付日期就要到了，产品却迟迟未集成完成，测试只能干等着上网聊QQ。就在下班前的一刻发布了，测试开始了紧张的测试，在屏幕闪动中，一个个的BUG提交，直到流程都无法都走不下去，测试无奈了。第二天就要发布，实施人员就等着制品第二天出差。只有不断的改，再发布，无尽的循环。直到大家都憔悴的看着老大，终于老大说：还剩下的这几个问题无关紧要，大家回去吧。

#### 几个月的开发过去后在总结会上，只能抱怨测试资源不足，时间太短，需求更改太多，需求更改后测试不知道。无数的问题一次一次的出现在同样的总结会议上。

#### 上面的这个例子很多人应该经历过，真的测试只有最后一刻才能体现价值吗？我想不是的。

#### 在后面的项目中我总结了这个问题的，针对每个开发任务要求进行测试验证。而测试如何验证呢？他需要知道这个开发任务的需求是如何，提前做好测试计划及测试用例，在接到开发制品后测试并提交BUG，这个工作是可以开发过程中就能不断的进行的。保证每一个任务的质量，可以大大减少后期集成的错误量。

#### 另外根据敏捷开发的思想，测试团队在开发过程中也需要加强与开发团队的交流，甚至有必要组成虚拟团队，位置调整到一起，这样可以及时快速的交流，参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度，反过来把握测试计划及测试内容。

#### 特别是测试从另一个角度来审视需求，这样也可以一定程度上发现或者改善需求上的不足。

#### 3、发挥团队人员的潜力

#### 敏捷开发比较提倡开发任务由开发自己评估并认领工作任务，这样可以激发开发的潜在动力。

#### 之前在做一个新产品时，需要使用java，而我们团队是使用C#的，面临转型问题。而有一位同事很感兴趣，于是我就让他负责前期的框架探索与搭建。结果就是这位小伙工作效率很高，我最初给他的目标全部都完成了。最有意思的是后面产品开始研发时，这位小伙已经成为了团队的大牛，大家有问题都找他解决。也正是因为这个过程，这位小伙被全面激活，也在大家面前展示了能力。甚至在小伙离职时也被领导给予大幅涨薪来挽留。只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢!

#### 所以充分发挥好每个人员的特点，让人能够在自己感兴趣的工作中，效果会很多。减少指派方式的任务的分配，充分发挥个人的主动性，这个团队精神面貌也会好很多。

#### 4、管理者不要离团队太远

#### 作为团队的Leader要参与到团队的工作中去，比如一个开发主管一定要写写代码，参与架构等对项目有关的事情，而不是在那里分分任务。这样团队成员才会觉得这个Leader很亲近感。

#### 特别是有些开发主管在带队后离团队越来越远，有时对于开发进度不如意时就说：“这么个简单功能怎么会搞了这么久？”，其实每天都在加班的同事心里想着：“有本事你来？”，即使这个小组长有这个能力，但对于团队来说也不是一件好事，因为大家都抱有怨恨之心，还谈什么好好工作呢？这个小组长就是失职的。所以这种情况下应该主动去了解进度滞后的原因，并且自己要加入到解决问题的工作中去，而不是在边上抱怨别人。

#### 5、小组织不要搞太多的官

#### 中国几千年的文化，官本位一直影响着我们，大家都想坐在那指挥，自己啥事也不用干，想想都惬意。在我们这个行业是不是发现也很类似？大家都想着干几年当个小组长，然后升个部门经理，当上CTO迎娶白富美。

#### 团队的管理基本是事与人的管理，非常的伤脑和心。如果一个组织内，特别是小组织内“官”太多，协调就会非常的难，大家就会经常性的扯皮。

#### 结束

## 敏捷开发的推理

### 符合现实的软件

### 软件是为着解决现实的问题而产生的。从而软件存在的意义就是与现实相适应。敏捷开发的核心即：符合现实的软件。一个符合现实的软件，才能够可持续地与现实共同发展。一旦软件与现实背离，软件的生命周期也就到了结束的时候了。

### 现实的世界是动态变化的，人类造出来的东西，往往是落后于世界的变化的。如，地图造出来之后，可能又多修了几条路，几个建筑；刚买了一款高配置的计算机，几个月后，自己的机器配置又处于被甩的地位了……这些变化，人是被迫要去接受。因为这些东西属于硬件，人在目前还无法轻易地改变硬件。

### 而与此不同的软件，则是另外一种现象了。改变软件的代价是相当低廉的。改变软件，实际上只是改变硬盘上的磁性。改变软件的容易性，带来的结果是： 一、软件开发者容易以自己的想象来决定软件怎么做。 开发出一个无用的软件，比起因为出错而要毁掉待出售的10万张地图，比起因为工艺漏洞而要招回已经出售的计算机来讲，代价太低廉了。 二、软件更加具备符合现实的条件。 开发者让软件与现实相适应，所要付出的代价非常低廉。

### 所以，敏捷开发的核心就是符合现实的软件。为了造出符合现实的软件，才有了进一步的价值观及方法论。

### 简单

### 简单，是在人认识到事物的本质的时候才能够获得的。在开发软件的时候，我们往往疲于应付各种各样的需求。很少有人能够将复杂的需求化为简单的概念。比如，做一个音乐软件，有“我喜欢的”、“最近播放”、“最新添加”等不同的性质的歌。有些开发者会做出三个列表来存放三种性质的歌。而实际上他们的本质是一样的，即播放列表。区别在于触发加入播放列表的条件不同而已。因而只需要做一个列表，在列表中标记每首歌的触发条件。

### 把软件做得很复杂，通常说明软件所抓住的本质还很少。需要再好好考虑一下如何进一步进行简化。软件的概念简单，一方面可以让用户很容易理解和操作；另一方面能够适应世界的变化。再拿以上的音乐软件来说。如何做成三个列表，再要加一个“听了又听”的歌，又得创建一个列表。而使用一个列表的方法，则只需要处理“听了又听”这个触发条件。

### 符合现实的软件必然是简单的。所以，敏捷开发的第一条价值观是：简单。我们在实施敏捷开发的时候，都是围绕“简单”这一价值观而进行实施的。即，时刻保证软件的简单性。简单性包括两个方面：一是对于用户而言，概念很简单；二是对于开发者而言，开发的技术及代码很简单。

### 软件的可持续性也取决于软件是否简单。可持续性是指，快速响应现实的变化。一个复杂的软件，要么让用户无所适从，要么让代码无法维护。这都将导致软件无法持续。这会迫使我们以制造硬件的方式来开发软件。硬件是在迫不得已的情况下才丢掉重新升级（计算机在实在没有办法用的时候，才买新的），要让软件也这样做，软件开发低廉代价的优势就白白浪费掉了。

### 反馈

### 一个软件要符合现实，就需要通过现实的反馈来发展。软件前进的动力是现实的反馈。敏捷开发是欢迎现实，拥抱变化的开发。强调该条价值观，是为了消除开发者容易犯的错误——以自己的想象去决定软件怎么做。

### 因而，在做一个软件之前，首先要找到能够给出反馈的人。如果连能够给出反馈的人都没有，那么这个软件就没有做的必要了。

### 反馈的重要性，更可以这样说：矛盾推动事物的发展。反馈是指出不足的矛，软件是弥补不足的盾。在矛的不断攻击之下，盾才能不断完善。矛之不存，盾何以壮。

### 在方法论上面，敏捷开发强调快速发布版本，取得现实的反馈而不是开发者大脑中自己想像的反馈。如果开发者正好也是使用者，那么软件做成的几率就要大很多。开源软件大多数都是开发者自己要解决问题而产生的。

### 沟通

### 沟通是开发者取得反馈的手段。一个优秀的开发者，是善于沟通的。沟通包含口语、写文档等各种方式。优秀的开发者应该能够清晰而有条理地表达自己的想法。

### 现实世界中，人们普遍认为：软件开发者因为跟机器打交道，从而是内向的，不善于沟通的。实际上，这样的开发者不能算是优秀的。他们所做的事情，更多地是把需求转化为计算机语言的工作，即翻译员。而现在都出来谷歌翻译了，人类语言翻译成计算机语言只是时间问题了。

### 沟通的目的是进行思想碰撞。在沟通当中了解别人的思维方式，表达自己的思维方式，进一步扬弃为更加优秀的思维方式。在优秀的思维方式之下才能保持让自己与现实相符合。优秀的开发者是不会放弃获取优秀的思维方式的机会的。

### 在敏捷开发当中，提出这一价值观，正是要开发者变得优秀。放弃优秀的开发者无法适应敏捷开发。

### 勇气

### 在现实生活中，缺乏勇气比较常见。比如，不敢大大方方地表白，不敢尝试新的事物……在软件开发领域，缺乏勇气更是常见：技术更新好几代了，公司还不敢使用新技术；公司不敢尝试新的开发模式（敏捷开发）……

### 勇气，本质上来讲，是对现状的否定。人们往往一厢情愿地相信永恒；一旦确定，就不愿意改变。这正是勇气的用武之地。勇气使人去否定永恒，拥抱改变。勇气是创造的源泉。人没有勇气，人就永远是他现在的这样了，正是勇气才迫使他去改变。

### 在开发的时候，我们可能花了很多时间写了很多代码，但要决定放弃已经写过的所有代码，这是非常需要勇气的。而如果能够做到这一点，在软件开发上就占据了非常有利的位置。比如，我们可能会花大量时间去写页面原型，以希望能够得到用户反馈。在确定得到用户反馈之后，我们可以完全放弃原型代码，进而可以得到更加符合现实（也更加简单）的代码。

### 敏捷开发强调勇气这一价值观，正是要开发者去拥抱现实的变化，让开发者及软件朝着符合现实的路线走。

### 迭代开发

### 讲完四个价值观之后，接下来我把四个价值观联系起来，得到一个方法论——迭代开发。

### 如图所示，简单是软件开发的起点，也是软件开发的终点。

### 说它是起点，是因为，如果开发的东西还是复杂的，那就有必要把概念弄得简单一些。这包含两个方面的行动：一、把复杂的系统砍掉一半的功能（广度上）；二、尽可能对各个功能进行抽象（深度上，参考前面音乐软件的例子）。

### 接下来，我们拿着简单的软件（或者软件原型）进入沟通环节。我们可以在两个方面进行沟通：一、与用户沟通软件的逻辑是否满足要求；二、与开发者沟通软件是否在技术上代价很高，如何权衡。

### 沟通之后，我们可以得到现实的反馈，在现实的反馈之下，我们才有勇气进行改变，使用我们的软件继续维持其简单性。这就完成了软件的一个迭代。

## 敏捷方法

### Scrum

#### Scrum是和种迭代式及递增式的敏捷软件开发框架，它用于管理软件项目，产品，或程序的开发。它的着重点是一个灵活的，全面的产品开发策略，它把一个开发团队通常作为一个单位进而实现一个常规目的。相反，它不着重于传递的序列化式的方法。Scrum会问传统瀑布式开发“为什么我们要花费这么长时间，这么多努力去做一件事？为什么我们不能衡量出做一件事所需时间和人力？” Scrum拥抱变化和创造力，因为这是人们的工作方式。Scrum有一个流程学习结构，能够让团队评估他们做了什么以及他们怎样做的。

#### Scrum角色

##### 产品持有人 Product Owner

\###### 产品持有人代表着公司或股东的权益并传递客户的声音。

\###### 专门负责确保商业价值

\###### 制定以客户为中心的一些工作条目，排序后放到产品待处理列表（Product backlog）中。

\###### Scrum团队应该有一个产品持有人，他/她也可以是开发团队中的一员。

\###### 产品持有人不是Scrum领导者(ScrumMaster)。

##### 开发团队 Development Team

\###### 在每一个Sprint周期结束后，负责交付将来需要发布的产品的模块。

\###### 由3到9人组成并拥有各种所需技能（分析，设计，开发，测试，技术沟通，文档，等等）。

\###### 自我组织，有可能需要与更高级的项目管理部门交流。

##### Scrum领导人 ScrumMaster

\###### 专门负责扫清团队在交付Sprint目标或产品中遇到的障碍。

\###### 不是团队领导人，但是扮演着团队与可能分散团队注意力的影响之间的缓冲区。

\###### 确保Scrum流程的使用在计划中。

\###### 规则强制执行人。团队保护者，以保持团队专注于他们手中的工作。

\###### 也会被看作一个人民公仆去加强这些双重观点。

\###### 不同于一个项目经理，没有与ScrumMaster不相关的人员管理职责

\###### 没有任何额外的员工责任。

#### 会议

##### 1、Sprint计划会议

\######   Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。

##### 2、每日例会

\#######

##### 3、Sprint评审会议

\#######

##### 4、Sprint回顾会议

\#######

#### 三个构件

##### 1、产品Backlog  产品Backlog指根据初始需求分解出的任务列表，包括功能性和非功能性的所有功能。

\###### Backlog未完成项列表

*   产品的待完成项列表是一个需求的排列列表，我们维护这个列表是为了更好的开发产品。它的组成有功能，BUG修复，非功能需求等任何为了成功发布可用软件系统的所必须的内容。在Scrum中，开始一个项目不必先开发一个冗长文档去记录所有的需求。这个敏捷产品backlog对于第一个Sprint足够了。当有更多产品需求时和客户需求时，Scrum产品backlog允许变更和增加。

*   Sprint backlog是开发团队下个Sprint需要处理的工作列表。这个列表是产品backlog最上面的需求项衍生出来的，直到开发团队在这个Sprint中有足够的工作去做。开发团队通过问一些问题来完成backlog的选择，如“我们是不是也能做这个？”。

*   从概念上讲，团队从优先级最高的Scrum backlog开始画一条线划分出优先级较低的项，同时线上面的backlog也是团队认为他们可以完成的项。在实践中，团队通常不会去选择优先级最高的五项再选择优先级较低的两项组合在一起即使它们是互相关联的。

##### 2、Sprint Backlog Sprint Backlog就是任务列表，如果映射到传统的项目管理理论中就是WBS（work breakdown structure)，而且是典型的采用面向交付物的任务分解方法得到的WBS。

\###### 任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。

##### 3、燃尽图。

#### 完成Scrum敏捷开发的流程为：

##### 第一步：Product Backing   找出完成产品需要做的事情。

##### 第二步\:Sprint Backlog   决定当前冲刺需要解决的事情。

##### 第三步：Sprint   冲刺。

\######  1.我昨天做了什么。

\###### 2.我今天要什么。

\######  3.我碰到了哪些问题。

##### 第四步：得到软件的一个增量版本，发布给用户。然后在此基础上进一步计划增量的新功能和改进。

#### Scrum开发的一些注意事项：

##### 1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；

##### 2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；

##### 3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1\~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；

##### 4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；

##### 5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天 要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；

##### 6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可 以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本 发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；

##### 7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；

##### 8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；

#### 需求收集

##### 1.1  需求的分类

\###### 需求可与分为业务团队的，也可以包括团度内部的，比如性能优化。

##### 1.2  需求提交模板

\###### 需求种类	优先级	需求类型	需求标题	详细描述	验收条件	价值验证	提交时间	需求人	备注

*   ① 需求种类 可从以下四种情况中选择

    *   – 概念想法

    *   – 可用性问题（Bug）

    *   – 任务

    *   – 性能问题

    *   注意：即使是概念性的想法，目前技术上无法实现的想法都可以收集。

##### ② 优先级 可从以下五种情况中选择

\###### – 普通

\###### – 非常重要

\###### – 特别的严重

\###### – 很重要

\###### – 低

\###### 注意：切忌将所有的任务的优先级都设置的非常的高，这里不提供非常紧急这样的表述。我们只会根据重要程度去执行任务，所以紧急的任务需要业务部门及需求方尽早的提出。

##### ③ 需求类型 可以是两种类型

\###### – 毛坯需求

\###### – 详细需求

\###### 注意：我们的需求并不是要求一定要完整的，及时是一些非常毛坯的需求，也可以提交过来，毛坯的需求由产品负责人进行分析和梳理，暂不清楚的可选择搁置。

##### ④ 需求标题 有自己进行书写，但是需要遵守的规范是采用动宾短语格式。

\###### 比如：“导出+CN酒店每天的PV、UV等流量数据”

\###### 注意：这里的需求内容一定是站长使用者角度是提出的，切勿出现专业的程序方面的表述：如添加一个导出的按钮。还有需要注意的是动词切忌使用大而宽泛的词，比如“管理”，类似“管理关键词”这样的需求是严格避免的，这样会使得要开发的内容变得没有清晰的边界。

##### ⑤ 详细描述 需要按照用户故事的格式进行书写。具体用户故事格式的要求如下：

\###### 活动：需要完成什么样的功能。

\###### 角色：谁要使用这个功能。

\###### 商业价值：为什么需要这个功能，这个功能带来什么样的价值。

##### 用户故事是从用户的角度来描述用户渴望得到的功能。需要注意的是用户故事不能够使用技术语言来描述，要使用用户可以理解的业务语言来描述。一个好的用户故事包括三个要素：

\###### 活动：需要完成什么样的功能。

\###### 角色：谁要使用这个功能。

\###### 商业价值：为什么需要这个功能，这个功能带来什么样的价值。

##### 用户故事通常按照如下的格式来表达：作为一个<角色>, 我想要<活动>, 以便于<商业价值>

##### 比如：作为一名酒店前端开发人员，我期望查看所有酒店页面的页面打开时间，以便了解哪些页面需要进行技能优化。

##### 一个好的用户故事同时要符合INVEST原则，INVEST原则分别是：

\###### 短小（Small）: 一个好的故事在工作量上要尽量短小，最好不要超过8个人/天的工作量,至少要确保的是在一个迭代能够完成。用户故事越大，在安排计划，工作量估算等方面的风险就会越大。

\###### 有价值（Valuable）: 每个故事必须对客户具有价值。一个让用户故事有价值的好方法是让客户来写下它们。一旦一个客户意识到这是一个用户故事并不是一个契约而且可以进行协商的时候，他们将非常乐意写下故事。

\###### 独立性（Independent）: 要尽可能的让一个用户故事独立于其他的用户故事。用户故事之间的依赖使得制定计划，确定优先级，工作量估算都变得很困难。通常我们可以通过组合用户故事和分解用户故事来减少依赖性。

\###### 可协商性（Negotiable）: 一个用户故事的内容要是可以协商的，用户故事不是合同。一个用户故事卡片上只是对用户故事的一个简短的描述，不包括太多的细节。具体的细节在沟通阶段产出。一个用户故事带有了太多的细节，实际上限制了和用户的沟通。

\###### 可以估算性（Estimable）:开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。但是让开发者难以估计故事的问题来自：对于领域知识的缺乏（这种情况下需要更多的沟通），或者故事太大了（这时需要把故事切分成小些的）。

\###### 可测试性（Testable）: 一个用户故事要是可以测试的，以便于确认它是可以完成的。如果一个用户故事不能够测试，那么你就无法知道它什么时候可以完成。

##### 注意：

##### 角色的范围不能过大，比如是作为一名“用户”，这样是的不被接受的。

##### 商业价值也不能大而宽泛，比如，能为公司创造业绩。如果要写也一定要对业绩做初步估算，比如，预期会给公司带来每月1万张订单。

##### ⑥ 验收条件 是开发完成后检验的标准，所以一定要认真填写，否则可能开发出来的东西与预期不达标。

\###### 4)   对于导出数据做好日志记录，后期可查是谁进行了导出。

\###### 2)   导出的时间可以细化的天。即可导出每天的流量。

\###### 以上面的“导出+CN酒店每天的PV、UV等流量数据”为例，它的验收条件可以为：

\###### 1)   可以为每个用户设置是否拥有此导出权限

\###### 3)   导出数据的最大时间跨度为31天

\###### 5)   导出的字段包括：PV、UV、跳出率、新访客占比。

##### ⑦   价值验证 说明如何跟踪上线后的效果

#### Sprint 计划会议 1

##### 目标：定出 Sprint 目标和既定产品 Backlog。

##### 2.1 会议准备

> Sprint 验收会议的时间安排

> Sprint 的最后一天已确定

> Sprint 计划会议 2 的时间安排

> Sprint 时间表已经安排

> 开发团队

> 产品负责人

> 在会议前一天确定议程，将目标和议程发送给所有与会者

> 投影仪

> 所有会议资源都已预订

> 会议室

> 笔记本

> 原始需求人（可选择不来）

> Scrum Master

> 已按优先级排列产品 Backlog整理完毕

> Sprint 计划会议 1 的时间安排

> Sprint 的第一天已确定

> Scrum 每日例会的时间安排

> Sprint 回顾会议的时间安排

##### 2.2 会议议程

> 如果对需求的优先级存在异议，可会上讨论，确定最终的执行顺序。

> 产品负责人或者原始需求者负责解答不清楚的故事点。

> 产品负责人向团队产品阐述需求（用户故事）

> 把 Sprint 时间表公开给所有人

> 开发人员对用户故事不清楚的点可以及时提出。

> 如果讨论现场发现有遗漏的需求，可由产品负责人添加至产品Backlog。

> 产品负责人& 需求方和小组成员相互认可这 Sprint 目标和既定产品 Backlog

##### 2.3 会议结果

> 为 Sprint 计划会议2的进行准备好既定产品 Backlog

##### 2.4 补充内容

\###### 需求种类	优先级	需求类型	需求标题	详细描述	验收条件	提交时间	需求人	备注	跟进人	预计完成时间	实际完成时间	Sprint版本号	处理情况

\###### 产品Backlog模板（基本同需求模板）

\###### 处理情况可从以下几种类型中选择

*   –    暂时搁置

*   –    已经完成

*   –    等待处理

*   –    正在进行

*   –    不予处理

*   –    需要讨论

#### Sprint 计划会议 2

> 目标：确定所有任务，生成 Sprint Backlog，确认 Sprint 目标

##### 3.1 会议准备

> Sprint 计划会议1中整理的既定产品 Backlog

> 开发团队

> 产品负责人

> 要求原始需求者离开会议，参会人员为

> Scrum Master

> 在Sprint 计划会议1后10分钟举行

> 任务估时牌（按1,2,3,5,8,13估算）

##### 3.2 会议进程

> 如果团队评估下来任务过多，可和产品负责人一起删减任务

> 可看情况确定是否使用扑克估时

> 部署

> 学习新技术

> 测试

> 团队成员按顺序分析既定产品 Backlog的讨论实现细节

> 编码

> 代码审核

> 编写文档

> 上传

> 任务超过一天时，需要拆成多个小任务

> 如果团队评估下来任务过少，可和产品负责人一起从产品Blaclog中引入新的需求。

##### 3.3 会议结果

> 将最终确认的可完成的需求清单邮件至

*   □ Scrum Master

*   □ 原始需求人

*   □ 产品负责人

*   □ 开发团队

> 将最终确认的任务列表邮件至

*   □ Scrum Master

*   □ 产品负责人

*   □ 开发团队

##### 3.4 补充内容

> 优先级	需求标题	详细描述	验收条件	需求人	跟进人	处理人	任务描述	处理日期	估时	实际耗时

> Sprint Backlog模板

> 需求和任务是一对多的关系，及一个需求可以产生多个任务，任务可以是程序类描述，如“数据数据库设计”

#### Scrum 每日例会

##### 目标：团队成员间工作进度的沟通和协调

##### 4.1 会议准备

> 在 Sprint Backlog 上的所有任务都是可以增删修改，可重排序的

> 外部团队协助人员（如有有需要的话）

> 邀请与会者

> 原始需求人（只有选择是否参加，过程中不可发言）

> 一台电脑，中间标识任务的状态，可设为“待处理”，“正在处理”，“已完成”的。

##### 4.2 会议进程

> 如果相关人员想发表些言论

> 如果展开了一个问题的讨论

> 有什么问题阻碍了你的开发

> 如果任务可以在一天内完成：把任务状态设为“正在处理”

> 如果任务不在 Sprint Backlog 上：添加这个任务

> 下一次会议之前，你计划完成什么任务？

> 上次会议时的任务哪些已经完成?

\###### – 会议限定在15分钟内

\###### 注意：

\###### – 团队里的每个成员都必须回答以下三个问题，并考虑其相关的行动。

\###### □把任务从“正在处理”状态转为“已完成”状态

> 如果任务状态为“待处理”：转为“正在处理”状态

> 如果任务不能在一天内完成：把这任务细分成多个任务

> 如果任务状态已经是“正在处理”：询问是否存在阻碍任务完成得问题

> 如果有阻碍你开发进度的问题：把该障碍加入到障碍 Backlog 中，Scrum Master负责记录

> 提醒团队的成员们注意把精力集中在回答关键问题上

> 礼貌地提醒他，该会议只允许让小组成员讨论

##### 4.3 会议结果

\###### 4.4 障碍Backlog

> 最新的工作进度图（燃尽图）

> 得到最新的障碍 Backlog

> 得到最新的 Sprint Backlog

> 第一次的例会创建一封邮件，由Scrum Master会议后将例会内容回复此邮件。

\###### 障碍 Backlog 列举了所有团队内部和团队相关的和阻碍项目进度的问题。Scrum Master 需要确保所有的障碍 Backlog 中的问题都已分配并可以得到解决。

*   10 大典型障碍

    *   –    团队的 Sprint Backlog 混乱

    *   –    团队人数过多

    *   –    并不是所有负责交付产品的人员都是团队里的成员

    *   –    没有产品负责人负责回答提问

    *   –    会议规则没能被遵循

    *   –    产品远景和 Sprint 目标不清晰

    *   –    产品 Backlog 未能按商业价值区分优先级

    *   –    Scrum Master 还要处理其他任务，不能集中精力

    *   –    团队没有能坐在一起工作的空间

    *   –    中间遇到了技术难题

#### Sprint 验收会议

##### 目标：根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。

##### 5.1 会议准备

> 对于每个人来说 Sprint 目标都是公开的

> Scrum Master

> 原始需求人（可选择不来）

> 笔记本

> 会议室

> 所有会议资源都已预订

> 投影仪

> 在会议前一天确定议程，将目标和议程发送给所有与会者

> 产品负责人

> 开发团队

> 对每个人来说既定产品 Backlog 是公开的，可获取的

##### 5.2 会议进程

> 如果对功能有一个新的想法：添加一个新问题到产品 Backlog 中

> 团队按 Backlog 中的问题，逐个地介绍这次 Sprint 的结果，和演示新功能。

> 如果产品负责人或需求方想要改变功能：添加一个新问题到产品 Backlog 中

> 如果小组报告项目遇到阻碍现在还没能解决：把该障碍加入到障碍 Backlog

##### 5.3 会议结果

> 对这次 Sprint 的结果和整个产品的开发状态的共识

#### Sprint 回顾会议

##### 目标：通过总结以往的实践经验来提高团队生产力。

##### 注意：主要指导原则：不管我们现在发现了什么问题，我们必须懂得并坚信每个人通过他们当时所知的，他所拥有的技能和可得到的资源，在限定的环境下，都尽其所能做出了最好的成绩。

##### 6.1 会议准备

> 在白板上写上“谁负责”，然后分成两个区域——“团队”和“公司”

> 在白板上写上“我们的成功经验是什么”

> 在白板上写上主要指导原则

> 便签纸

> 产品负责人（可选）

> Scrum Master

> 邀请与会者：

> 团队所有成员

> 附属工具

> 白板

> 在白板上画上一个至少三页纸连在一起长的时间轴

> 在白板上写上“有什么能够改进”

\###### 附属工具：

##### 6.2 会议进程

> 给会议做个总结

> 把便签纸移到挂纸板中“谁负责”的区域中

> 对于挂纸板上“有什么能够改进”的区域中的每一项

> 分发便签纸，并让每人写上“有什么能够改进的”，限时5分钟

> 分发便签纸，并让每人写上“我们的成功经验是什么”，限时5分钟

> 派发便签，并且让每人写上他们认为这次 Sprint 中最为重要的事，限时 5 分钟

> 在时间轴上，标记出 Sprint 的开始和结束时间

> 介绍会议目标

> 介绍会议主要指导原则

> 向与会者解说如何使用该便签纸进行工作

> 每个与会者轮流把他的贴纸贴到白板的时间轴上，并用两句话来解说这事有什么特别的地方

> 每个与会者轮流把他的贴纸贴到白板“我们的成功经验是什么”的区域上，并解说。

> 每个与会者轮流把他的贴纸贴到白板“有什么能够改进的”的区域上，并解说。

> 询问团队“谁去负责解决这个问题？”

> 和团队一起把这些区域按优先次序排好

\###### □每个与会者对 Sprint 回顾会议作简短的回馈

##### 6.3 会议结果

> 把与团队范围相关的障碍增加到障碍 Backlog 中去

> 白板上“谁负责”这栏对于公司内所有人是公开的

> 把与公司范围相关的障碍增加到障碍 Backlog 中去

> 整理所有会议结果，邮件至团队中所有人

### 极限编程XP

#### 极限编程是一个轻量级的、灵巧的软件开发方法；

同时它也是一个非常严谨和周密的方法。
它的基础和价值观是交流、朴素、反馈和勇气；
即，任何一个软件项目都可以从四个方面入手进行改善：加强交流；
从简单做起；寻求反馈；勇于实事求是。
XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；
通过积极的交流、反馈以及其它一系列的方法，
开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。

##### 开发人员知道要做什么，以及要优先做什么；

##### 工作有效率；

##### 有问题或困难时，能得到客户、同事、上级的回答或帮助；

##### 对工作做评估，并根据周围情况的变化及时重新评估；

##### 积极承担工作，而不是消极接受分配；

##### 一周40小时工作制，不加班。

#### 与其他方法论相比，其最大的不同在于

##### 在更短的周期内，更早地提供具体、持续的反馈信息。

##### 在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。

##### 依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。

##### 依赖于口头交流、测试和源程序进行沟通。

##### 倡导持续的演化式设计。

##### 依赖于开发团队内部的紧密协作。

##### 尽可能达到程序员短期利益和项目长期利益的平衡。

#### 四大价值观

##### XP的核心是其总结的沟通、简单、反馈、勇气四大价值观，它们是XP的基础，也是XP的灵魂。

##### 1. 沟通

\###### 通畅程序员给人留下的印象就是“内向、不善言谈”，然后项目中的许多问题就出在这些缺乏沟通的开发人员身上。经常由于某个程序员做出了一个设计决定，但是却不能及时地通知大家，结果使得大家在协作与配合上出现了很多的麻烦，而在传统的方法论中，并不在意这种口头沟通不畅的问题，而是希望借助于完善的流程和面面俱到的文档、报表、计划来替代，但是这同时又引入了效率不高的新问题。

\###### XP方法论认为，如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起，从这个角度能够发现，通过文档、报表等人工制品进行交流面临巨大的局限性。因此，XP组合了诸如对编程这样的最佳实践，鼓励大家进行口头交流，通过交流解决问题，提高效率。

##### 2. 简单

\###### 另外，在XP中提倡时刻对代码进行重构，一直保持其良好的结构与可扩展性。也就是说，可扩展性和为明天设计并不是同一个概念，XP是反对为明天考虑而工作，并不是说代码要失去扩展性

\###### 正如对传统开发方法的认识一样，许多开发人员也会质疑XP，保持系统的扩展性很重要，如果都保持简单，那么如何使得系统能够有良好的扩展性呢？其实不然，保持简单的理由有两个：

\###### XP方法论提倡在工作中秉承“够用就好”的思路，也就是尽量地简单化，只要今天够用就行，不考虑明天会发现的新问题。这一点看上去十分容易，但是要真正做到保持简单的工作其实很难的。因为在传统的开发方法中，都要求大家对未来做一些预先规划，以便对今后可能发生的变化预留一些扩展的空间。

\###### 开发小组在开发时所做的规划，并无法保证其符合客户需要的，因此做的大部分工作都将落空，使得开发过程中重复的、没有必要的工作增加，导致整体效率降低。

\###### 而且简单和沟通之间还有一种相对微妙的相互支持关系。当一个团队之间，沟通的越多，那么就越容易明白哪些工作需要做，哪些工作不需要做。另一方面，系统越简单，需要沟通的内容也就越少，沟通也将更加全面。

##### 3. 反馈

\###### 在开发过程中，还应该加强集成工作，做到持续集成，使得每一次增量都是一个可执行的工作版本，也就是逐渐是软件长大，整个过程中，应该通过向客户和管理层演示这些可运行的版本，以便及早地反馈，及早地发现问题。

\###### 而且在项目的过程中，这样的现象不仅出现在开发团队与客户、管理层之间，还包括在开发团队内部。这一切问题都需要我们更加注重反馈。，反馈对于任何软件项目的成功都是至关重要的，而在XP方法论中则更进一步，通过持续、明确的反馈来暴露软件状态的问题。具体而言就是：

\###### 是什么原因使得我们的客户、管理层这么不理解开发团队？为什么客户、管理层总是喜欢给我们一个死亡之旅？究其症结，就是开发的过程中缺乏必要的反馈。在许许多多项目中，当开发团队经历过了需求分析阶段之后，在相当长的一段时间内，是没有任何反馈信息的。整个开发过程对于客户和管理层而言就像一个黑盒子，进度完全是可见的。

\###### 在开发团队内部，通过提前编写单元测试代码，时时反馈代码的问题与进展。

\###### 同时，我们也会发现反馈与沟通也有着良好的配合，及时和良好的反馈有助于沟通。而简单的系统更有利于测试盒反馈。

##### 4. 勇气

\###### 也就是XP方法论要求开发人员穿上强大、自动测试的盔甲，勇往直前，在重构、编码规范的支持下，有目的地快速开发。

\###### 在应用XP方法论时，我们每时每刻都在应对变化：由于沟通良好，因此会有更多需求变更的机会；由于时刻保持系统的简单，因此新的变化会带来一些重新开发的需要；由于反馈及时，因此会有更多中间打断你的思路的新需求。

\###### 总之这一切，使得你立刻处于变化之中，因此这时就需要你有勇气来面对快速开发，面对可能的重新开发。也许你会觉得，为什么要让我们的开发变得如此零乱，但是其实这些变化若你不让它早暴露，那么它就会迟一些出现，并不会因此消亡，因此，XP方法论让它们早出现、早解决，是实现“小步快走”开发节奏的好办法。

\###### 勇气可以来源于沟通，因为它使得高风险、高回报的试验成为可能；勇气可以来源于简单，因为面对简单的系统，更容易鼓起勇气；勇气可以来源于反馈，因为你可以及时获得每一步前进的状态（自动测试），会使得你更勇于重构代码。

##### 5. 四大价值观之外

##### 在这四大价值观之下，隐藏着一个更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间的相互关心、相互理解的基础之上。

#### 5个原则

##### 1. 快速反馈

\###### 及时地、快速地获取反馈，并将所学到的知识尽快地投入到系统中去。也就是指开发人员应该通过较短的反馈循环迅速地了解现在的产品是否满足了客户的需求。这也是对反馈这一价值观的进一步补充。

##### 2. 简单性假设

\###### 类似地，简单性假设原则是对简单这一价值观的进一步补充。这一原则要求开发人员将每个问题都看得十分容易解决，也就是说只为本次迭代考虑，不去想未来可能需要什么，相信具有将来必要时增加系统复杂性的能力，也就是号召大家出色地完成今天的任务。

##### 3. 逐步修改

\###### 就像开车打方向盘一样，不要一次做出很大的改变，那样将会使得可控性变差，更适合的方法是进行微调。而在软件开发中，这样的道理同样适用，任何问题都应该通过一系列能够带来差异的微小改动来解决。

##### 4. 提倡更改

\###### 在软件开发过程中，最好的办法是在解决最重要问题时，保留最多选项的那个。也就是说，尽量为下一次修改做好准备。

##### 5. 优质工作

\###### 在实践中，经常看到许多开发人员喜欢将一些细小的问题留待后面解决。例如，界面的按钮有一些不平整，由于不影响使用就先不管；某一两个成员函数暂时没用就不先写等。这就是一种工作拖泥带水的现象，这样的坏习惯一旦养成，必然使得代码质量大打折扣。

\###### 而在XP方法论中，贯彻的是“小步快走”的开发原则，因此工作质量决不可打折扣，通常采用测试先行的编码方式来提供支持。

#### 13个最佳实践

##### 在XP中，集成了13个最佳实践，有趣的是，它们没有一个是创新的概念，大多数概念和编程一样老。其主要创新点在于提供一种良好的思路，将这些最佳实践结合在一起，并且确保尽可能彻底地执行它们，使得它们能够在最大程度上相互支持，紧接下来，我们就对每一种最佳实践进行一番了解。

##### 1. 计划游戏

\###### 开发人员进行估算：首先客户按优先级将用户故事分成必须要有、希望有、如果有更好三类，然后开发人员对每个用户故事进行估算，先从高优先级开始估算。如果在估算的时候，感到有一些故事太大，不容易进行估算，或者是估算的结果超过2人/周，那么就应该对其进行分解，拆成2个或者多个小故事。

\###### 好了，明白这些就可以进行计划游戏了。首先客户和开发人员坐在同一间屋子里，每个人都准备一支笔、一些用于记录用户故事的纸片，最好再准备一个白板，就可以开始了。

\###### 计划游戏的主要思想就是先快速地制定一份概要的计划，然后随着项目细节的不断清晰，再逐步完善这份计划。计划游戏产生的结果是一套用户故事及后续的一两次迭代的概要计划。

\###### “客户负责业务决策，开发团队负责技术决策”是计划游戏获得成功的前提条件。也就是说，系统的范围、下一次迭代的发布时间、用户故事的优先级应该由客户决定；而每个用户故事所需的开发时间、不同技术的成本、如何组建团队、每个用户故事的风险，以及具体的开发顺序应该有开发团队决定。

\###### 客户编写故事：由客户谈论系统应该完成什么功能，然后用通俗的自然语言，使用自己的语汇，将其写在卡片上，这也就是用户故事。

\###### 确定迭代的周期：接下来就是确定本次迭代的时间周期，这可以根据实际的情况进行确定，不过最佳的迭代周期是2\~3周。有了迭代的时间之后，再结合参与的开发人数，算出可以完成的工作量总数。然后根据估算的结果，与客户协商，挑出时间上够、优先级合适的用户故事组合，形成计划。

##### 2. 小型发布

\###### XP方法论秉承的是“持续集成，小步快走”的哲学，也就是说每一次发布的版本应该尽可能的小，当然前提条件是每个版本有足够的商业价值，值得发布。

\###### 由于小型发布可以使得集成更频繁，客户获得的中间结果也越频繁，反馈也就越频繁，客户就能够实时地了解项目的进展情况，从而提出更多的意见，以便在下一次迭代中计划进去。以实现更高的客户满意度。

##### 3. 隐喻

\###### 描述体系结构：体系结构是比较抽象的，引入隐喻能够大大减轻理解的复杂度。例如管道体系结构就是指两个构件之间通过一条传递消息的“管道”进行通信。

\###### 发明共享词汇：通过隐喻，有助于提出一个用来表示对象、对象间的关系通用名称。例如，策略模式（用来表示可以实现多种不同策略的设计模式）、工厂模式（用来表示可以按需“生产”出所需类得设计模式）等。

\###### 相对而言，隐喻这一个最佳实践是最令人费解的。什么是隐喻呢？根据词典中的解释是：“一种语言的表达手段，它用来暗示字面意义不相似的事物之间的相似之处”。那么这在软件开发中又有什么用呢？总结而言，常常用于四个方面。

\###### 寻求共识：也就是鼓励开发人员在寻求问题共识时，可以借用一些沟通双方都比较熟悉的事物来做类比，从而帮助大家更好地理解解决方案的关键结构，也就是更好地理解系统是什么、能做什么。

\###### 创新的武器：有的时候，可以借助其他东西来找到解决问题的新途径。例如：“我们可以将工作流看做一个生产线”。

\###### 当然，如果能够找到合适的隐喻是十分快乐的，但并不是每种情况都可以找到恰当的隐喻，你也没有必要强求

##### 4. 简单设计

\###### 使用Demeter（迪米特）法则：迪米特法则，也称为LoD法则、最少知识原则。也就是指一个对象应当对其他对象尽可能少地了解。用隐喻的方法来解释的话就是“只与你直接的朋友通信”、“不要和陌生人说话”。

\###### 首先写测试代码：具体将在后面详细描述。

\###### 他认为要想保持设计简单的系统，需要具备简单思考的能力，拥有理解代码和修改的勇气，以及为了消除代码的“坏味道”而定期重构的习惯。

\###### 清楚地表现了程序员赋予的所有意图。

\###### 能够通过所有的测试程序。

\###### 强调简单设计的价值观，引出了简单性假设原则，落到实处就是“简单设计”实践。这个实践看上去似乎很容易理解，但却又经常被误解，许多批评者就指责XP忽略设计是不正确的。其实，XP的简单设计实践并不是要忽略设计，而且认为设计不应该在编码之前一次性完成，因为那样只能建立在“情况不会发生变化”或者“我们可以预见所有的变化”之类的谎言的基础上的。

\###### Kent Beck概念中简单设计是这样的：

\###### 没有包括任何重复的代码。

\###### 包括尽可能少的类和方法

\###### 那么如何开始进行简单的设计呢？XP实践者们也总结也一些具体的、可操作的思考方法。

\###### 保持每个类只负责一件事：SRP（单一职责原则）是面向对象设计的基础原则之一。

\###### 使用CRC卡片进行探索。

##### 5. 测试先行

\###### 工匠一：先拉上一根水平线，砌每一块砖时，都与这跟水平线进行比较，使得每一块砖都保持水平。

\###### 你会选择哪种工作方法呢？你一定会骂工匠二笨吧！这样多浪费时间呀！然而你自己想想，你平时在编写程序的时候又是怎么做的呢？我们就是按工匠二的方法在工作呀！甚至有时候比工匠二还笨，是整面墙都砌完了，直接进行“集成测试”，经常让整面的墙倒塌。看到这里，你还会觉得自己的方法高明吗？这个连工匠都明白的道理，自己却画地为牢呀。

\###### 为了鼓励程序员原意甚至喜欢在编写程序之前编写测试代码，XP方法论还提供了许多有说服力的理由。

\###### 如果你在结对编程，那么如果你想出一个好的测试代码，那么你的伙伴一定行。

\###### 当你的客户看到所有的测试都通过的时候，会对程序充满前所未有的信心。

\###### 测试先行是XP方法论中一个十分重要的最佳实践，并且其中所蕴含的知识与方法也十分丰富。

\###### 当你需要进行重构时，测试代码会给你带来更大的勇气，因为你要测试是否重构成功只需要一个按钮。

\###### 当所有的测试都通过的时候，你再也不会担心所写的代码今后会“暗箭伤人”，那种感觉是相当棒的。

\###### 如果你已经保持了简单的设计，那么编写测试代码根本不难。

\###### 不仅我们没有采用工匠一的工作方法，甚至有的时候程序员会以“开发工作太紧张”为理由，而忽略测试工作。但这样却导致了一个恶性循环，越是没有空编写测试程序，代码的效率与质量越差，花在找Bug、解决Bug的时间也越来越多，实际产能大打降低。由于产能降低了，因此时间更紧张，压力更大。你想想，为什么不拉上一根水平线呢？难道，我们不能够将后面浪费的时间花在单元测试上，使得我们的程序一开始就更健壮，更加易于修改吗？不过，编写测试程序当然要比拉一条水平线难道多，所以我们需要引入“自动化测试工具”，免费的xUnit测试框架就是你最佳的选择。

\###### 工匠二：先将一排砖都砌完，然后再拉上一根水平线，看看哪些砖有问题，对有问题的砖进行适当的调整。

\###### 当我第一次看到“测试先行”这个概念的时候，我的第一感觉就是不解，陷入了“程序都还没有写出来，测试什么呀？”的迷思。我开始天马行空地寻求相关的隐喻，终于找到了能够启发我的工匠，首先，我们来看看两个不同的工匠是如何工作的吧。

##### 6. 重构

\###### 实现某个特性之前：尝试改变现有的代码结构，以使得实现新的特性更加容易。

\###### 在《重构》一书中，作者Martin Fowler提示我们：在考虑重构时，应该要养成编写并经常运行测试代码的习惯；要先编写代码，再进行重构；把每一次增加功能都当做一次重构的好时机；将每一个纠正错误当做一次重构的重要时机。同时，该书中也列出大量需要重构的情况和重构方法。

\###### XP提倡集体代码所有制，因此你可以大胆地在任何需要修改的地方做改动。

\###### 在重构中遇到困难，和你结对编程的伙伴能够为你提供有效的帮助。

\###### 测试先行让你拥有了一个有效的检验器，随时运行一下就知道你重构的工作是否带来了影响。

\###### 重构技术是对简单性设计的一个良好的补充，也是XP中重视“优质工作”的体现，这也是优秀的程序员必备的一项技能。

\###### 由于XP在持续集成，因此你重构所带来的破坏很快就能够暴露，并且得以解决。

\###### 简单的设计，会给重构带来很大的帮助。

\###### 由于在XP项目组中有完整的编码标准，因此在重构前无须重新定义格式。

\###### 最后类似地，给还没有足够勇气进行重构的程序员打几剂强心针：

\###### 实现某个特性之后：检查刚刚写完的代码后，认真检查一下，看是否能够进行简化。

\###### 重构时一种对代码进行改进而不影响功能实现的技术，XP需要开发人员在闻到代码的坏味道时，有重构代码的勇气。重构的目的是降低变化引发的风险，使得代码优化更加容易。通常重构发生在两种情况之下。

##### 7. 结对编程

\###### 不过，自从20世纪60年代，就有类似的实践在进行，长期以来的研究结果却给出了另外一番景象，那就是结对编程的效率反而比单独编程更高。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐渐加快，究其原因，主要是结对编程大打降低了沟通的成本，提供了工作的质量，具体表现在：

\###### 系统的任何一个部分都肯定至少有2个人以上熟悉。

\###### 结对组合的动态性，是一个企业知识管理的好途径。

\###### 而且XP方法论集成的其他最佳实践也能够使得结对编程更加容易进行：

\###### 隐喻可以帮助结对伙伴更好地沟通。

\###### 结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型的实践，应用得当还能够使得开发团队之前的协作更加流畅、知识交流与共享更加频繁，团队的稳定性也会更加稳固。

\###### 简单设计可以使得结对伙伴更了解他们所从事的工作。

\###### 编码标准可以消除一些无谓的分歧。

\###### 代码总是能够保证被评审过。

\###### 几乎不可能有2个人都忽略的测试项或者其他任务

\###### 所有的设计决策确保不是由一个人做出的。

\###### “什么！两个人坐在一起写程序？那岂不是对人力的巨大浪费吗？而且我在工作时可不喜欢有一个人坐在边上当检察官。”是的，正如这里列举出来的问题一样，结对编程技术还是被很多人质疑的。

##### 8. 集体代码所有制

\###### 也就是说，团队中的每个成员都拥有对代码进行改进的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时，XP强调代码是谁破坏的（也就是修改后发生问题），就应该由谁来修复。

\###### 由于在XP项目中，集成工作是一件经常性得工作，因此当有人修改代码而带来了集成的问题，会在很快的时间内被发现。

\###### 由于每一个代码的修改就是通过了结对的两个程序员共同思考，因此通常做出的修改都是对系统有益的。

\###### 集成代码所有制是XP与其他敏捷方法的一个较大不同，也是从另一个侧面体现了XP中蕴含的很深厚的编码情节。

\###### 由于大家都坚持了相同的编码标准，因此代码的可读性、可修改性都会比较好，而且还能够避免由于命名法、缩进等小问题引发经常性得代码修改。

\###### 由于每一个类都会有一个测试代码，因此不论谁修改了代码，都需要运行这个测试代码，这样偶然性的破坏发生的概率将很小。

\###### 由于在XP中，有一些与之匹配的最佳实践，因此你并无须担心采用集体代码所有制会让你的代码变得越来越乱：

\###### 由于XP方法论鼓励团队进行结对编程，而且认为结对编程的组合应该动态地搭配，根据任务的不同、专业技能的不同进行最优组合。由于每个人都肯定会遇到不同的代码，所以代码的所有制就不再适合于私有，因为那样会给修改工作带来巨大的不便。

##### 9. 持续集成

\###### 这样，就可以及早地暴露、消除由于重构、集体代码所有制所引入的错误，从而减少解决问题的痛苦

\###### 在前面谈到小型发布、重构、结对编程、集体代码所有制等最佳实践的时候，我们多次看到“持续集成”的身影，可以说持续集成是对这些最佳实践的基本支撑条件。

\###### 可能大家会对持续集成与小型发布代表的意思混淆不清，其实小型发布是指在开发周期经常发布中间版本，而持续集成的含义则是要求XP团队每天尽可能多次地做代码集成，每次都在确保系统运行的单元测试通过之后进行。

\###### 要在开发过程中做到持续集成并不容易，首先需要养成这个习惯。而且集成工作往往是十分枯燥、烦琐的，因此适当地引入每日集成工具是十分必要的。XP建议大家首先使用配置管理服务器将代码管理起来，然后使用Ant或Nant等XP工具，编写集成脚本，调用xUint等测试框架，这样就可以实现每当程序员将代码Check in到配置服务器上时，Ant就会自动完成编译和集成，并调用测试代码完成相应的测试工作。

##### 10. 每周工作40小时

\###### Kent Beck认为开发人员即使能够工作更长的时间，他们也不该这样做，因为这样做会使他们更容易厌倦编程工作，从而产生一些影响他们效能的其他问题。因此，每周工作40小时是一种顺势行为，是一种规律。其实对于开发人员和管理者来说，违反这种规律是不值得的。

\###### 管理者：也许这可以称得上“第二种人月神话”，那就是你不得不通过延长每天的工作时间来获得更多的人月。这是因为，每个开发人员的工作精力是有限的，不可能无限增长，在精力不足的时候，不仅写出来的代码质量没有保障，而且还可能为项目带来退步的效果。因此采用加班的方式并不是一个理性的方式，是得不偿失的。

\###### 不过有一点是需要解释的，“每周工作40小时”中的40不是一个绝对数，它所代表的意思是团队应该保证按照“正常的时间”进行工作。那么如何做到这一点呢？

*   其次，逐步将工作时间调整到“正常工作时间”。

*   最后，鼓起勇气，制定一个合情合理的时间表。

*   正如米卢说过的“享受足球”一样，同样地，每一个开发人员应该做到“享受编程”，那么“每周工作40小时”就是你的起点。

*   再次，除非你的时间计划一团糟，否则不应该在时间妥协。

*   首先，定义符合你团队情况的“正常工作时间”。

\###### 开发人员：如果不懂得休息，那么就无法将自己的节奏调整到最佳状态，那么就会带来很大的负面影响。而且在精神不集中的状态下，开发质量也得不到保证。

\###### 这是最让开发人员开心的、管理者反对的一个最佳实践了，加班、再加班早已成为开发人员的家常便饭，也是管理者最常使用的一种策略，而XP方法论认为，加班最终会扼杀团队的积极性，最终导致项目失败，这也充分体现了XP方法关注人的因素比关注过程的因素更多一些。

##### 11. 现场客户

\###### 也许有人会问，客户提交了用户故事之后不就完成工作了吗？其实很多尝试过用户故事的团队都会发现其太过简单，包含的信息量极少，XP方法论不会不了解，因此，不会把用户故事当做开发人员交付代码的唯一指示。用户故事只是一个起点，后面的细节还需要开发人员与客户之间建立起来的良好沟通来补充。

\###### 其实现场客户在具体实施时，也不是一定需要客户一直和开发团队在一起，而是在开发团队应该和客户能够随时沟通，可以是面谈，可以是在线聊天，可以是电话，当然面谈是必不可少的。其中的关键是当开发人员需要客户做出业务决策是，需要进一步了解业务细节时能够随时找到相应的客户。

\###### 当开发组织中已经有相关的领域专家时。

\###### 去尝试吧，现场客户不仅可以争取得到，而且还能使得团队焕然一新，与客户建立起良好的合作与信任。

\###### 当做一些探索性工作，而且客户也不知道他想要什么时（例如新产品、新解决方案的研究与开发）。

\###### 不过，也有一些项目是可以不要现场客户参与的：

\###### 作为一名有经验的开发人员，绝对不会对现场客户的价值产生任何怀疑，但是都会觉得想要实现现场客户十分困难。要实现这一点，需要对客户进行沟通，让其明白，想对于开发团队，项目成功对于客户而言更为重要。而现场客户则是保障项目成功的一个重要措施，想想在你装修房子的时候，你是不是常常在充当现场客户的角色呢？其实这隐喻就是让客户理解现场客户重要性最好的突破口。

\###### 为了保证开发出来的结果与客户的预想接近，XP方法论认为最重要的需要将客户请到开发现场。就像计划游戏中提到过的，在XP项目中，应该时刻保证客户负责业务决策，开发团队负责技术决策。因此，在项目中有客户在现场明确用户故事，并做出相应的业务决策，对于XP项目而言有着十分重要的意义。

##### 12. 编码标准

\###### 不过，XP方法论的编码标准的目的不是创建一个事无巨细的规则表，而是只要能够提供一个确保代码清晰，便于交流的指导方针。

\###### 如果你的团队已经拥有编码标准，就可以直接使用它，并在过程中进行完善。如果还没有，那么大家可以先进行编码，然后在过程中逐步总结出编码规则，边做边形成。当然除了这种文字规范以外，还可以采用一些如自动格式化代码工具之类的方法进行代码规范。，事实上，你只需要很好地贯彻执行其他的实践并且进行沟通，编码标准会很容易地浮现出来。

\###### 编码标准是一个“雅俗共享”的最佳实践，不管是代表重型方法论的RUP，PSP，还是代表敏捷方法论的XP，都认为开发团队应该拥有一个编码标准。XP方法论认为拥有编码标准可以避免团队在一些与开发进度无关的细节问题上发生争论，而且会给重构、结对编程带来很大麻烦。试想如果有人将你上次写的代码的变量命名法做了修改，下次你需要再改这部分代码时，会是一种什么感觉呢？

##### 13. 配合是关键

##### 有句经典名言“1+1>2”最适合表达XP的观点，Kent Beck认为XP方法论的最大价值在于在项目中融会贯通地运用12个最佳实践，而非单独地使用。你当然可以使用其中的一些实践，但这并不意味着你就运用了XP方法论。XP方法论真正能够发挥其效能，就必须完整地运用12个实践。

### 水晶方法

#### 水晶方法，Crystal ，

是由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，
其目的是发展一种提倡“机动性的”方法，
包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。
Crystal 家族实际上是一组经过证明、对不同类型项目非常有效的敏捷过程，
它的发明使得敏捷团队可以根据其项目和环境选择最合适的 Crystal 家族成员。
水晶系列与XP一样，都有以人为中心的理念，但在实践上有所不同。

#### 七大特征

##### 体系特征一：经常交付

##### 体系特征二：反思改进

##### 体系特征三：渗透式交流

##### 体系特征四：个人安全

##### 体系特征五：焦点

##### 体系特征六：与专家用户建立方便的联系

##### 体系特征七：配有自动测试、配置管理和经常集成功能的技术环境

### DSDM-动态系统开发方法

#### Dynamic System Development Management，

它倡导以业务为核心，快速而有效地进行系统开发。
实践证明DSDM是成功的敏捷开发 方法之一。
在英国，由于其在各种规模的软件组织中的成功，
它已成为应用最为广泛的快速应用开发方法。
主要内容：DSDM如何加快产品的 交付，
为什么像DSDM这样的敏捷开发方法能够快速体现所开发系统给业务带来的好处，
如何组织用户参与项目以开发出可用的系统，
如何将不同知识背景的人组 成一个团队，
如何应对常规的业务约束以进行项目管理。

#### 基本原则

##### 原则1：用户必须持续参与 active user involvement is imperative

##### 原则2：必须授予DSDM团队制定决策的权利 DSDM teams are empowered to make decisions including refining or changing requirements without the direct involvement of higher management

##### 原则3：注重产品的经常交付 The focus is on frequent product delivery

##### 原则4：满足业务用户用途是接受交付品的主要依据 Fitness for purpose is the key criterion

\###### 开发人员不必沉溺于完美的 解决方案之中，耽误项目时间。在受限的时间内，实现业务利益最大化的交付品才是最重要的。

##### 原则5：迭代和增量式开发对得到正确的业务解决方案是必不可少的 Iterative and incremental development is necessary to converge on an accurate business solution

\###### 采用迭代开发的方法，能够使业务流程逐步进化，使系统不断朝着满足业务需求的方向前进。

##### 原则6：开发过程的所有变化可逆 All changes during development are reversible

\###### 采用迭代和增量式开发过程中，很可能会碰到走错的情况，此时需要回退到一个已知的可靠的点上。

##### 原则7：在高层次上制定需求的基线 Requirements are initially agreed at a high level

\###### 在业务研究中所得出的需求必须在高层次上达成一致。接下来在迭代过程中再得到详细的需求。

##### 原则8：测试自始至终贯穿于开发周期之中 Testing is integrated throughout the life cycle — this is essential with an incremental approach

\###### 开发人员完成一个模块的开发后，自己会进行单元测试。当模块集成到现有系统后，测试人员需要执行集成测试。另外，回归测试在DSDM中占有很重 要的地位。

##### 原则9：所有项目涉众间的通力合作是不可获缺的 A collaborative and co-operative approach between all stakeholders is essential

### 测试驱动开发

#### 测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱动整个开发过程的进行。这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。

#### 测试驱动开发的基本过程如下：

##### ①　快速新增一个测试

##### ②　运行所有的测试（有时候只需要运行一个或一部分），发现新增的测试不能通过

##### ③　做一些小小的改动，尽快地让测试程序可运行，为此可以在程序中使用一些不合情理的方法

##### ④　运行所有的测试，并且全部通过

##### ⑤　重构代码，以消除重复设计，优化设计结构

#### 简单来说，就是不可运行/可运行/重构——这正是测试驱动开发的口号。

测试驱动开发不是一种测试技术，它是一种分析技术、设计技术，更是一种组织所有开发活动的技术。
相对于传统的结构化开发过程方法优势:

##### 1) TDD根据客户需求编写测试用例，对功能的过程和接口都进行了设计，而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求。因为关注用户反馈，可以及时响应需求变更，同时因为从使用者角度出发的简单设计，也可以更快地适应变化。

##### 2) 出于易测试和测试独立性的要求，将促使我们实现松耦合的设计，并更多地依赖于接口而非具体的类，提高系统的可扩展性和抗变性。而且TDD明显地缩短了设计决策的反馈循环，使我们几秒或几分钟之内就能获得反馈。

##### 3) 将测试工作提到编码之前，并频繁地运行所有测试，可以尽量地避免和尽早地发现错误，极大地降低了后续测试及修复的成本，提高了代码的质量。在测试的保护下，不断重构代码，以消除重复设计，优化设计结构，提高了代码的重用性，从而提高了软件产品的质量。

##### 4) TDD提供了持续的回归测试，使我们拥有重构的勇气，因为代码的改动导致系统其他部分产生任何异常，测试都会立刻通知我们。完整的测试会帮助我们持续地跟踪整个系统的状态，因此我们就不需要担心会产生什么不可预知的副作用了。

##### 5) TDD所产生的单元测试代码就是最完美的开发者文档，它们展示了所有的API该如何使用以及是如何运作的，而且它们与工作代码保持同步，永远是最新的。

##### 6) TDD可以减轻压力、降低忧虑、提高我们对代码的信心、使我们拥有重构的勇气，这些都是快乐工作的重要前提。

##### 7)快速的提高了开发效率。

#### ，

### Lean软件开发（精益软件开发）

#### 面对开发团队以及最终的产品大小的额外挑战，可以说软件开发是个持续学习的过程。最佳的改善软件开发环境的做法就是增强学习。在代码完成后马上进行测试可以避免缺陷的累积。不是去做成更多的文档或详细设计，而是对各种各样的想法进行实际的编码尝试。用户需求的收集过程可以简单地通过给最终客户演示，并听取他们的反馈来完成。

#### 使用短周期的迭代（每个迭代都应包括重构和集成测试）可以加速学习过程。在决定当前阶段的开发内容并对未来改善的努力方向进行调整时，在客户端帮助下通过简短的反馈会议来增强反馈。通过这些简短的反馈会议，客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案。从而，基于已开发出的原型，客户可以更好地理解自己的需求，开发者也能了解到如何才能更好地满足客户的需求。另一个关于和客户沟通、学习的想法是“基于组的开发”，这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案，因此通过和客户的对话加速了解决方案的产生。

#### 原则

##### 消除浪费

##### 增强学习

##### 尽量延迟决定

##### 尽快发布

##### 下放权力

##### 嵌入质量

##### 全局优化

### 轻量型RUP

#### RUP其实是个过程的框架，它可以包容许多不同类型的过程， Craig Larman 极力主张以敏捷型方式来使用RUP。

他的观点是:目前如此众多的努力以推进敏捷型方法，只不过是在接受能被视为RUP 的主流OO开发方法而已。

#### RUP 是一种以架构为中心的开发过程，而这正是大、中型项目成功的关键。

#### RUP（Rational Unified Process）是一个风险驱动的基于UML 和构件式架构的迭代递增型开发过程（框架）。RUP 定义了4 个阶段（起始、细化、构造、移交）和9 个科目（业务建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境）。这些阶段对应着关键里程碑的划分，而不同科目的工作流和活动 在生命周期的迭代中可以并发进行，具体执行的程度则可以调节。RUP 对于角色、流程、工件和活动的要求是灵活的、可配置的，所以它广泛地适用于各种类型和规模的项目。RUP 集中体现了6 个软件开发的最佳实践方法：迭代式开发、需求管理、构件式架构、基于UML 的可视化建模、持续校验质量、变更管理。

#### RUP认为下面这些最佳实践可以改善软件的开发状况：

##### 在早期迭代中解决高风险和高价值的问题

##### 不断的让用户参与评估、反馈和需求

##### 在早期迭代中建立内聚的核心架构

##### 不断地验证质量：提早、经常和实际的测试

##### 可视化软件建模（使用UML）

##### 仔细的管理需求

##### 实行变更请求和配置管理

#### 四个阶段

##### 初始阶段（Inception)：

预见项目的范围、构想和业务案例 （Lifecycle Objective）

\###### 初始阶段不是一个需求阶段，而是类似与可行性阶段，项目相关人员是否就项目的构想达成基本的一致，项目是否值得继续进行认真的研究

\###### 时间不应超过一周，只需要确定这个项目是否值得认真研究，而不是真正去深入研究项目（这个工作留待细化阶段进行）如果预选就决定项目必须进行，而且项目明显是可行的，那么初始阶段会很短，可能只包含一次需求研讨会，并为第一次迭代执行计划，然后就快速的进入细化阶段

\###### 主要实践活动－用例建模

\###### 对于迭代开发的一个关键理解在于：过程中的工件在初始阶段只是部分完成，在之后的迭代中在逐步精化提炼。例如，用例模型可以列举大多数所需的用例和参与者，但其中可能只有10％的用例会被详细描述，这样就足以建立起有关系统的范围、目标和风险的高层的大致构想。

\###### 主要工件：是否意味着大量的文档？工件是可选的，只需要从下面选择对项目确实有价值的工件，放弃哪些不必要的工件，工件的关键不是文档或图表本身，而是其中蕴含的思想、分析和前期准备。

*   构想和业务案例：描述高层的目标和约束、业务案例，并提供一个执行摘要

*   用例模型：描述功能需求和相关的非功能需求

*   补充规范：描述其他需求

*   术语表：关键的领域术语

*   风险列表和风险管理计划：描述业务、技术、资源和进度的风险，以及如何减轻这些风险或该如何应对

*   原型和概念验证：阐明构想，验证技术问题。

*   迭代计划：描述在第一次细化迭代中该作什么

*   阶段计划和软件开发计划：对细化阶段的持续时间和工作量进行低精度的猜测。开发涉及的工具、人员、培训和其他资源

*   开发案例：描述为本项目定制的统一过程的步骤和工件。在统一过程中，总需要为项目定制一些步骤或工件

##### 细化阶段（Elaboration）：

已精化的构想，核心架构的迭代实现，高风险的解决，大多数需求和范围的识别，更为现实的评估。 （Lifecycle Architecture）

\###### 细化阶段不是一个需求或设计阶段，而是一个迭代实现核心架构并降低高风险的阶段

\###### 在细化前不需要定义大多数需求，10％的详细用例书写出来即可

\###### 先处理具有风险的元素，开始实际产品代码的编写，产生可执行架构

\###### 除了极少数理解良好的问题外需要多次迭代

##### 构造阶段（Construction）：

迭代实现遗留下来的风险较低和比较容易的元素，准备部署 （Initial Operational Capability）

##### 移交阶段（Transition）：

beta测试，部署 （Product Release）

#### 多个流程

##### 业务建模：在开发单独的应用时，业务建模包括领域对象建模。在从事大规模业务分析或业务过程再工程时，业务建模包括跨越整个企业的业务过程的动态建模。

##### 需求：对应用的需求分析，如写出用例和识别非功能性需求

##### 分析和设计：设计的所有方面，包括总体架构、对象、数据库、网络连接等。分析强调的是对问题和需求的调查研究，而不是解决方案。设计强调的是满足需求的概念上的解决方案，而不是其实现。分析和设计可以被概括为：作正确的事（分析）和正确的做事（设计）。

##### 实现：编程和构建系统，而不是部署系统

##### 测试

##### 配置和变更管理

##### 项目管理

##### 环境：指建立工具并为项目定制过程，也就是说，设置工具和过程环境。

##### 1－5为核心工作流程，6－8为支持工作流程

##### The way of controlling

\###### 如何计划和管理迭代：需要多少迭代？每次迭代多长时间？每次迭代的目的是什么？如何跟踪每次迭代情况？

*   The Phase Plan (Project Plan)：一个粗略的计划，每个开发项目只有一份项目计划。包括了一个周期（cycle）内所有的环节（有时也可以包含多个周期）。计划包含主要里程碑的时间，要求的资源。如果能够明确分几个iteratio，则需要标识时每个小里程碑的时间和目的。

*   The Iteration Plan：迭代计划，包含当前迭代的详细计划，包括时间、任务和资源分配，在当前迭代后半期还需要包含下一个迭代的计划

\###### 风险管理

\###### 度量

##### The way of supporting

##### The way of communicating

\###### RUP定义了一系列流程和工件，这些工作作为各角色间沟通的主要内容，用例和架构是RUP的两个重要内容。

\###### 用例驱动开发：使用用例表达需求，对业务进行描述。用例作为整个开发流程的基础。

\###### 架构为中心流程：架构使用多个、协调一致的视图来表达系统，作为概念、构建、管理和演进系统的主要工件

#### 模型和流程对应

##### 角色: the who

##### 活动: the how

##### 工件：the what

##### 工作流: the when

##### 规程（Disciplines）: 组合前面四种元素

#### 六大经验

##### 迭代式开发。在软件开发的早期阶段就想完全、准确的捕获用户的需求几乎是不可能的。实际上，我们经常遇到的问题是需求在整个软件开发工程中经常会改变。迭代式开发允许在每次迭代过程中需求可能有变化，通过不断细化来加深对问题的理解。迭代式开发不仅可以降低项目的风险，而且每个迭代过程以可以执行版本结束，可以鼓舞开发人员。

##### 管理需求。确定系统的需求是一个连续的过程，开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求。RUP描述了如何提取、组织系统的功能和约束条件并将其文档化，用例和脚本的使用以被证明是捕获功能性需求的有效方法。

##### 基于组件的体系结构。组件使重用成为可能，系统可以由组件组成。基于独立的、可替换的、模块化组件的体系结构有助于管理复杂性，提高重用率。RUP描述了如何设计一个有弹性的、能适应变化的、易于理解的、有助于重用的软件体系结构。

##### 可视化建模。RUP往往和UML联系在一起，对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力。RUP告诉我们如何可视化的对软件系统建模，获取有关体系结构于组件的结构和行为信息。

##### 验证软件质量。在RUP中软件质量评估不再是事后进行或单独小组进行的分离活动，而是内建于过程中的所有活动，这样可以及早发现软件中的缺陷。

##### 控制软件变更。迭代式开发中如果没有严格的控制和协调，整个软件开发过程很快就陷入混乱之中，RUP描述了如何控制、跟踪、监控、修改以确保成功的迭代开发。RUP通过软件开发过程中的制品，隔离来自其他工作空间的变更，以此为每个开发人员建立安全的工作空间。

#### 核心概念

##### 角色：描述某个人或者一个小组的行为与职责。RUP预先定义了很多角色。

##### 活动：是一个有明确目的的独立工作单元。

##### 工件：是活动生成、创建或修改的一段信息。

#### RUP裁剪

##### RUP是一个通用的过程模板，包含了很多开发指南、制品、开发过程所涉及到的角色说明，由于它非常庞大所以对具体的开发机构和项目，用RUP时还要做裁剪，也就是要对RUP进行配置。RUP就像一个元过程，通过对RUP进行裁剪可以得到很多不同的开发过程，这些软件开发过程可以看作RUP的具体实例。RUP裁剪可以分为以下几步：

##### 1)        确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。

##### 2)        确定每个工作流需要哪些制品。

##### 3)        确定4个阶段之间如何演进。确定阶段间演进要以风险控制为原则，决定每个阶段要那些工作流，每个工作流执行到什么程度，制品有那些，每个制品完成到什么程度。

##### 4)        确定每个阶段内的迭代计划。规划RUP的4个阶段中每次迭代开发的内容。

##### 5)        规划工作流内部结构。工作流涉及角色、活动及制品，他的复杂程度与项目规模即角色多少有关。最后规划工作流的内部结构，通常用活动图的形式给出。

# 面向对象

## 结构化与面向对象方法特点比较

> 1.  从概念方面看，

> > 结构化软件是功能的集合，通过模块以及模块和模块之间的分层调用关系实现；面向对象软件是事物的集合，通过对象以及对象和对象之间的通讯联系实现；

> 1.  从构成方面看

> > 结构化软件＝过程＋数据，以过程为中心；面向对象软件＝（数据＋相应操作）的封装，以数据为中心；

> 1.  从运行控制方面看

> > 结构化软件采用顺序处理方式，由过程驱动控制；面向对象软件采用交互式、并行处理方式，由消息驱动控制；

> 1.  从开发方面看，

> > 结构化方法的工作重点是设计；面向对象方法的工作重点是分析；

> > > 在结构化方法中需要把在分析阶段采用的具有网络特征的数据流图转换为设计阶段采用的具有分层特征的结构图，在面向对象方法中则不存在这一问题。

> 1.  从应用方面看，

> > 相对而言，结构化方法更加适合数据类型比较简单的数值计算和数据统计管理软件的开发；面向对象方法更加适合大型复杂的人机交互式软件和数据统计管理软件的开发；

## OOD(Object Oriented Design)

> OOD就是“根据需求决定所需的类、类的操作以及类之间关联的过程”。

> OOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。我们刚才说到：OOD是一种抽象的范式。抽象可以分成很多层次，从非常概括的到非常特殊的都有，而对象可能处于任何一个抽象层次上。另外，彼此不同但又互有关联的对象可以共同构成抽象：只要这些对象之间有相似性，就可以把它们当成同一类的对象来处理。

> 面向对象设计（Object-Oriented Design，OOD）方法是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。

> 面向对象设计（OOD）是一种软件设计方法，是一种工程化规范。这是毫无疑问的。按照Bjarne Stroustrup的说法，面向对象的编程范式（paradigm）是\[Stroustrup, 97]：

> 由这个定义，我们可以看出：OOD就是“根据需求决定所需的类、类的操作以及类之间关联的过程”。

> OOD的目标是管理程序内部各部分的相互依赖。为了达到这个目标，OOD要求将程序分成块，每个块的规模应该小到可以管理的程度，然后分别将各个块隐藏在接口（interface）的后面，让它们只通过接口相互交流。比如说，如果用OOD的方法来设计一个服务器-客户端（client-server）应用，那么服务器和客户端之间不应该有直接的依赖，而是应该让服务器的接口和客户端的接口相互依赖。

> 这种依赖关系的转换使得系统的各部分具有了可复用性。还是拿上面那个例子来说，客户端就不必依赖于特定的服务器，所以就可以复用到其他的环境下。如果要复用某一个程序块，只要实现必须的接口就行了。

> OOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。我们刚才说到：OOD是一种抽象的范式。抽象可以分成很多层次，从非常概括的到非常特殊的都有，而对象可能处于任何一个抽象层次上。另外，彼此不同但又互有关联的对象可以共同构成抽象：只要这些对象之间有相似性，就可以把它们当成同一类的对象来处理。

### OOD步骤

> 决定你要的类；

> 给每个类提供完整的一组操作；

> 明确地使用继承来表现共同点。

> 细化重组类

> 细化和实现类间关系,明确其可见性

> 增加属性,指定属性的类型与可见性

> 分配职责,定义执行每个职责的方法

> 对消息驱动的系统,明确消息传递方式

> 利用设计模式进行局部设计

> 画出详细的类图与时序图

### OOD设计过程中要展开的主要几项工作

#### （一）对象定义规格的求精过程

> 对于OOA所抽象出来的对象-＆-类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，使之更能符合OOP的需要。这个整理和求精过程主要有两个方面：一是要根据面向对象的概念

> 模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。二是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归

> 类，对类一＆一对象、属性、方法和结构、主题进行归类。

#### （二）数据模型和数据库设计

> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。

#### （三）优化

> OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。

> 对象和结构的模块化表示OOD提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。

> 集成化使得单个构件有机地结合在一起，相互支持。

#### 六、OO方法的特点和面临的问题

> OO方法以对象为基础，利用特定的软件工具直接完成从对象客体的描述到软件结构之间的转换。这是OO方法最主要的特点和成就。OO方法的应用解决了传统结构化开发方法中客观世界描述工具与软

> 件结构的不一致性问题，缩短了开发周期，解决了从分析和设计到软件模块结构之间多次转换映射的繁杂过程，是一种很有发展前途的系统开发方法。

> 但是同原型方法一样,OO方法需要一定的软件基础支持才可以应用，另外在大型的MIS开发中如果不经自顶向下的整体划分，而是一开始就自底向上的采用OO 方法开发系统，同样也会造成系统结构不合理、各部分关系失调等问题。所以OO方法和结构化方法目前仍是两种在系统开发领域相互依存的、不可替代的方法。

### 实现UML建模

#### (1)  业务对象的提取

#### (2)  根据SRS、CRC等实现用况建模

#### (3)  实现业务顺序图

#### (4)  建立类图，根据用况图建立对象之间的关联

#### (5)  绘制活动图、实现协作图、状态图

## OOP(Object Oriented Programming)

> 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。OOP 主要有以下的概念和组件：

> 组件 － 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。

> 抽象性 － 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。

> 封装 － 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。

> 多态性 － 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。

> 继承性 － 允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。

> 由于抽象性、封装性、重用性以及便于使用等方面的原因，以组件为基础的编程在脚本语言中已经变得特别流行。Python 和 Ruby 是最近才出现的语言，在开发时完全采用了 OOP 的思想，而流行的 Perl 脚本语言从版本5开始也慢慢地加入了新的面向对象的功能组件。用组件代替“现实”上的实体成为 JavaScript（ECMAScript） 得以流行的原因，有论证表明对组件进行适当的组合就可以在英特网上代替 HTML 和 XML 的文档对象模型（DOM）。

> 设计模式、技术和直觉构成严峻的挑战。这是选择编程语言之前必须认识到的，尽管不同语言的设计特性可能促进或者阻碍这一转化。

> 在网络应用的增长中，一个很重要的部分是小型移动设备和特殊Internet设备的爆炸性增长。这些设备各有各的操作系统，或者只在某种特定的设备领域内有共同的操作系统。我们现在还可以一一列举出这些设备——家庭接入设备、蜂窝电话、电子报纸、PDA、自动网络设备等等。但是这些设备领域的数量和深入程度将会很快变得难以估量。我们都知道这个市场大得惊人，PC的兴起与之相比不过小菜一碟。因此在这些设备的应用程序市场上，竞争将会相当残酷。获胜的重要手段之一，就是尽快进入市场。开发人员需要优秀的工具，迅速高效地撰写和调试他们的软件。平台无关性也是制胜秘诀之一，它使得程序员能够开发出支持多种设备平台的软件。

> 我预期的另一个变化是，我们对于代码(Java)和数据(XML)协同型应用程序的开发能力将会不断提高。这种协同是开发强大应用程序的核心目标之一。我们从XML的迅速流行和ebXML规范的进展中，已经看到了这个趋势。ebXML是一个针对电子商务和国际贸易的，基于XML的开放式基础构架，由联合国贸易促进和电子商务中心(UN/CEFACT)与结构性信息标准推进组织(OASIS)共同开发。

> 我们能否期望出现一个真正的面向组件(component-oriented)的语言？它的创造者会是谁呢？

> Stroustrup: 我怀疑，这个领域中之所以缺乏成果，正是因为人们——主要是那些非程序员们——对“组件”这个意义含糊的字眼寄予了太多的期望。这些人士梦想，有朝一日，组件会以某种方式把程序员赶出历史舞台。以后那些称职的“设计员”只需利用预先调整好的组件，把鼠标拖一拖放一放，就把系统组合出来。对于软件工具厂商来说，这种想法还有另一层意义，他们认为，到时候只有他们才保留有必要的技术，有能力编写这样的组件。

> 这种想法有一个最基本的谬误：这种组件很难获得广泛欢迎。一个单独的组件或框架(framework)，如果能够满足一个应用程序或者一个产业领域对所提出的大部分要求的话，对于其制造者来说就是划算的产品，而且技术上也不是很困难。可是该产业内的几个竞争者很快就会发现，如果所有人都采用这些组件，那么彼此之间的产品就会变得天下大同，没什么区别，他们将沦为简单的办事员，主要利润都将钻进那些组件/框架供应商的腰包里！

> 小“组件”很有用，不过产生不了预期的杠杆效应。中型的、更通用的组件非常有用，但是构造时需要非同寻常的弹性。

## OOA(Object Oriented Analyzing)

### 需要做什么

> 为完成用户要求系统应提供哪些功能?

> 系统应有哪些对象构成?

> 每个对象应有哪些属性和服务?

> 对象间应有怎样的联系?要

### 怎么做

> 个体特征分析:标识对象及其属性和服务。

> 静态分析:分析和描述系统的静态结构。

> 动态分析:分析对象及之间的行为及其控制关系,建立系统的动态模型。

### 主要原则

#### （1）抽象

> 抽象原则包括过程抽象和数据抽象两个方面。过程抽象是指，任何一个完成确定功能的操作序列。数据抽象是根据施加于数据之上的操作来定义数据类型。

#### （2）封装

> 就是把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节。

#### （3）继承

> 继承原则的好处是：使系统模型比较简练也比较清晰。

> 特殊类的对象拥有的其一般类的全部属性与服务，称作特殊类对一般类的继承。

#### （4）分类

> 就是把具有相同属性和服务的对象划分为一类，用类作为这些对象的抽象描述。分类原则实际上是抽象原则运用于对象描述时的一种表现形式。

#### （5）聚合

> 又称组装，其原则是：把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述。

#### （6）关联

> 是人类思考问题时经常运用的思想方法：通过一个事物联想到另外的事物。能使人发生联想的原因是事物之间确实存在着某些联系。

#### （7）消息通信

> 这一原则要求对象之间只能通过消息进行通信，而不允许在对象之外直接地存取对象内部的属性。通过消息进行通信是由于封装原则而引起的。在OOA中要求用消息连接表示出对象之间的动态联系。

#### （8）粒度控制

> 一般来讲，人在面对一个复杂的问题域时，不可能在同一时刻既能纵观全局，又能洞察秋毫。因此需要控制自己的视野：考虑全局时，注意其大的组成部分，暂时不详察每一部分的具体的细节；考虑某部分的细节时则暂时撇开其余的部分。这就是粒度控制原则。

#### （9）行为分析

> 现实世界中事物的行为是复杂的。由大量的事物所构成的问题域中各种行为往往相互依赖、相互交织。

### 三种分析模型

#### 1、对象模型

> 对用例模型进行分析,把系统分解成互相协作的分析类,通过类图/对象图描述对象/对象的属性/对象间的关系,是系统的静态模型

#### 2、动态模型

> 描述系统的动态行为,通过时序图/协作图描述对象的交互,以揭示对象间如何协作来完成每个具体的用例,单个对象的状态变化/动态行为可以通过状态图来表达

#### 3、功能模型(即用例模型作为输入)。

### OOA主要优点

> （1）加强了对问题域和系统责任的理解；

> （2）改进与分析有关的各类人员之间的交流；

> （3）对需求的变化具有较强的适应性；

> （4）支持软件复用。

> （5）贯穿软件生命周期全过程的一致性。

> （6）实用性；

> （7）有利于用户参与。

### 基本步骤

#### 第一步，确定对象和类。

> 这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界中某些事物的信息的能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。

#### 第二步，确定结构（structure）。

> 结构是指问题域的复杂性和连接关系。类成员结构反映了泛化-特化关系，整体-部分结构反映整体和局部之间的关系。

#### 第三步，确定主题（subject）。

> 主题是指事物的总体概貌和总体分析模型。

#### 第四步，确定属性（attribute）。

> 属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。

#### 第五步，确定方法（method）。

> 方法是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。

### 面向对象

#### 第一步是抽取建立领域的概念模型

> 在UML中表现为建立对象类图、活动图和交互图。

> 对象类就是从对象中经过“察同”找出某组对象之间的共同特征而形成类：

> 对象与类的属性：数据结构；

> > 对象与类的服务操作：操作的实现算法；

> > 对象与类的各外部联系的实现结构；

> > 设计策略：充分利用现有的类；

> > 方法：继承、复用、演化；

> > 活动图用于定义工作流，

> > 主要说明工作流的5W（Do What、Who Do、When Do、Where Do、Why Do）等问题，交互图把人员和业务联系在一起是为了理解交互过程，发现业务工作流中相互交互的各种角色。

#### 第二步是构建完善系统结构：

> > 对系统进行分解，将大系统分解为若干子系统，

> > 子系统分解为若干软件组件，

> > 并说明子系统之间的静态和动态接口，

> > 每个子系统可以由用例模型、分析模型、设计模型、测试模型表示。

> > 软件系统结构的两种方式：层次、块状

> > 层次结构：系统、子系统、模块、组件（同一层之间具有独立性）；

> > 块状结构：相互之间弱耦合

> > 系统的组成部分：

> > > 问题论域：业务相关类和对象(OOA的重点)；

> > > 人机界面：窗口、菜单、按钮、命令等等；

> > > 数据管理：数据管理方法、逻辑物理结构、操作对象类；

> > > 任务管理：任务协调和管理进程；

#### 第三步是利用“4＋1”视图描述系统架构

> > 用例视图及剧本；说明体系结构的设计视图；

> > 以模块形式组成包和层包含概要实现模型的实现视图；

> > 说明进程与线程及其架构、分配和相互交互关系的过程视图；

> > 说明系统在操作平台上的物理节点和其上的任务分配的配置视图。在RUP中还有可选的数据视图。

#### 第四步是性能优化

> > （速度、资源、内存）、模型清晰化、简单化（简单就是享受）。

## 基本

### 类

#### 抽象类

> 抽象类是提供多个派生类共享基类的公共定义，它既可以提供抽象方法，也可以提供非抽象方法。抽象类不能实例化，必须通过继承由派生类实现其抽象方法，因此对抽象类不能使用new关键字，也不能被密封。如果派生类没有实现所有的抽象方法，则该派生类也必须声明为抽象类。另外，实现抽象方法由override方法来实现。

##### 抽象类的特点：

> (1). 抽象类是一个类，可以包含类的一切东西：属性、字段、委托、方法。

> (2). 抽象方法必须包含在抽象类中，抽象方法没有方法体，但抽象类中还可以包含普通的非抽象方法。

> (3). 抽象类和抽象方法的关键字均为abstract。

> (4). 继承抽象类的子类中，必须显式的覆写(override)其父类中的所有抽象方法。

> (5). 抽象类不能直接被实例化，声明的对象只能使用抽象类中已有的方法，不能使用子类新增的方法。

> (6). 同一个类只能继承唯一一个父类。

##### 对比父类中的虚方法(virtual)和抽象方法(abstract)的区别：

> (1). 抽象方法没有方法体，其继承子类必须对其进行覆写(override).

> (2). 虚方法有方法体，其继承子类可以对其进行覆写(override)，可以不进行覆写。若进行覆写，调用的则是子类中覆写后的方法；若不进行覆写，则调用的是父类     中的方法。

> (3). 抽象方法的关键字是abstract，且必须存在于抽象类中；虚方法的关键字是virtual，可以存在于任何类中。

#### 属性

#### 方法

### 对象

### 接口

> > 接口是包含一组虚方法的抽象类型，其中每一种方法都有其名称、参数、返回值。接口方法不能包含任何实现，CLR允许接口可以包含事件、属性、索引器、静态方法、静态字段、静态构造函数以及常数。
> > 但是接口不能包含任何静态成员。一个类可以实现多个接口，当一个类实现某个接口时，它不仅要实现该接口定义的所有方法，还要实现该接口从其他接口中继承的所有方法。

> (1). 接口不是类，里面可以包含属性、方法、事件，但不能包括字段和静态成员。

> (2). 接口只能包含没有实现的方法。

> (3). 子类实现接口，必须要实现该接口定义的所有方法，还要实现该接口从其他接口中继承的所有方法。

> (4). 接口不能被直接实例化，声明的对象只能使用接口中的方法，不能使用子类新增的方法。

> (5). 同一个类可以实现多个接口。

### 关系

#### 依赖（Dependency）：

> 两个事物间的语义关系，其中一个事物发生了变化会影响到另一个事物。

#### 关联（Association）：

> 是一种结构关系，它描述了一组链，链是对象之间的连接。比如一个人为一家公司工作（WorksFor），这里WorksFor就是一个关联。

#### 链接（link）：

> 是对象之间物理上或概念上的连接。例如：张三为微软公司工作（WorksFor），这里WorksFor就是一个链接。

#### 聚合（Aggregation）：

> 其是一种特殊形式的关联。表示整体与部分的关系。比如项目组与其各成员之间的关系就是一种聚合关系。

#### 组合关系（Composition）：

> 其也是一种特殊形式的关联。表示整体拥有各个部分，部分与整体共存。比如一个窗口是由文本框、列表框、菜单等组成的。关闭窗口，各个组成部分也相继消失，窗口与其各组成部分之间的关系便是组合关系。Ao对象中FeatureClass与Feature之间就是一种组合关系。

#### 泛化（Generalization）：

> 其是一种特殊/一般关系，特殊元素（子元素）/的对象可替代一般元素（父元素）的对象。也称为“Is a关系”。

#### 实现（Realization）：

> 是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。

#### 符号

> Class1 <|-- ClassA:泛化（子类继承父类）

> Class2 <-- ClassB:关联（成员变量）

> Class3 \*-- ClassC:组合（是整体与部分的关系，但部分不能离开整体而单独存在）

> Class4 o-- ClassD:聚合（Aggregation 整体与部分）

> Class5 <|.. ClassE:实现（类实现接口）

> Class6 <.. ClassF:依赖（局部变量、方法的参数或者对静态方法的调用）

### 面向对象的三大特征

#### (1). 封装

> > 将一些行为以类为单位进行包裹起来，然后通过类进行调用（如People类），可以利用private、public、protected灵活控制属性的可访问性。

> ①：保证数据安全（灵活使用private、public、protected进行控制）

> ②：屏蔽细节，只要方法名不变，可以随意扩展。

> ③：代码重用

#### (2). 继承

> > 通过继承，子类可以拥有父类的一切动作（如Student类继承People类）

#### (3). 多态

> > 多态有很多种。

> ①：通过不同子类继承同一个父类，实现多态（类似的还有子类继承抽象类、或者实现接口）

> ②：方法的重载本身就是一种多态

> ③：利用默认参数实现方法多态（利用命名参数实现方法的重载，即方法的多态）

> ④：运行时的多态（里氏替换原则，声明父类对象，调用虚方法，在子类覆写或者不覆写的情况下，分别调用子类方法或父类方法《只有在运行的时候才知道》）

### 抽象类和接口的比较

> > 相同点

> 1.  都不能被直接实例化，都可以通过继承实现其抽象方法。

> 1.  都是面向抽象编程的技术基础，实现了诸多的设计模式。

> > 不同点

> 1.  接口支持多继承；抽象类不能实现多继承。

> 1.  接口只能定义抽象规则；抽象类既可以定义规则，还可能提供已实现的成员。

> 1.  接口是一组行为规范；抽象类是一个不完全的类，着重族的概念。

> 1.  接口可以用于支持回调；抽象类不能实现回调，因为继承不支持。

> 1.  接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含有实现的方法。

> 1.  接口可以作用于值类型和引用类型；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。

> > 规则与场合

> 1.  请记住，面向对象思想的一个最重要的原则就是：面向接口编程。

> 1.  借助接口和抽象类，23个设计模式中的很多思想被巧妙的实现了，我认为其精髓简单说来就是：面向抽象编程。

> 1.  抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。

> 1.  接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系；

> 1.  接口多定义对象的行为；抽象类多定义对象的属性；

> 1.  接口定义可以使用public、protected、internal 和private修饰符，但是几乎所有的接口都定义为public，原因就不必多说了。

> 1.  在接口中，所有的方法都默认为public。

> 1.  “接口不变”，是应该考虑的重要因素。所以，在由接口增加扩展时，应该增加新的接口，而不能更改现有接口。

> 1.  尽量将接口设计成功能单一的功能块，以.NET Framework为例，IDisposable、IDisposable、IComparable、IEquatable、IEnumerable等都只包含一个公共方法。

> 1.  接口名称前面的大写字母“I”是一个约定，正如字段名以下划线开头一样，请坚持这些原则。

> 1.  如果预计会出现版本问题，可以创建“抽象类”。例如，创建了狗（Dog）、鸡（Chicken）和鸭（Duck），那么应该考虑抽象出动物（Animal）来应对以后可能出现风马牛的事情。而向接口中添加新成员则会强制要求修改所有派生类，并重新编译，所以版本式的问题最好以抽象类来实现。

> 1.  从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。

> 1.  对抽象类不能使用new关键字，也不能被密封，原因是抽象类不能被实例化。

> 1.  在抽象方法声明中不能使用 static 或 virtual 修饰符。（abstract 不能与static 或virtual一起用）

> > MSDN建议

> 1.  如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单易行的方法来控制组件版本。通过更新基类，所有继承类都随更改自动更新。另一方面，接口一旦创建就不能更改。如果需要接口的新版本，必须创建一个全新的接口。

> 1.  如果创建的功能将在大范围的全异对象间使用，则使用接口。抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。

> 1.  如果要设计小而简练的功能块，则使用接口。如果要设计大的功能单元，则使用抽象类。

> 1.  如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类。抽象类允许部分实现类，而接口不包含任何成员的实现。

> .NET Framework中关于接口和抽象类的使用：

> 集合类使用了基于接口的设计，请关注System.Collections中关于接口的设计实现；

> 数据流相关类使用了基于抽象类的设计，请关注System.IO.Stream类的抽象类设计机制。

## 其他问题

### 面向对象与面向过程区别

> 5.1、面向对象是将事物高度抽象化。

> 5.2、面向过程是一种自顶向下的编程

> 5.3、面向对象必须先建立抽象模型，之后直接使用模型就行了。

> 5.4、面向过程(OP)和面向对象(OO)本质的区别在于分析方式的不同，最终导致了编码方式的不同。

## 面向对象设计原则

### 1、单一职责原则 SRP

> （Single Responsibility Principle）

> 一个类，只有一个引起它变化的原因。主要是解耦合高内聚。

### 2、开闭原则 OCP

> （Open Close Principle）

> 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，易于维护和升级。

### 3、里氏代换原则 LSP

> （Liskov Substitution Principle）

> 任何基类可以出现的地方，子类一定可以出现。

### 4、依赖倒转原则 DIP

> （Dependence Inversion Principle）

> 就是要依赖于抽象，不要依赖于具体实现。

### 5、接口隔离原则 ISP

> （Interface Segregation Principle）

> 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好，也是降低类之间的耦合度。

### 6、合成复用原则 CRP

> （Composite Reuse Principle）

> 要尽量使用组合/聚合关系，少用继承。

### 7、迪米特法则（最少知道原则）DP

> （Demeter Principle）

> 一个软件实体应当尽可能少的与其他实体发生相互作用。

## Gof设计模式

> GoF:（Gang of Four，GOF设计模式）---四人组

> Design Patterns: Elements of Reusable Object-Oriented Software（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John

> Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为“四人组（Gang of Four）”，而这本书也就被称为“四人组（或 GoF）”书。

### 行为型

#### Iterator（迭代器模式）

> Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

#### Interpreter（解析器模式）

> Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

#### Observer（观察者模式）

> Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。

#### Mediator（中介者模式）

> Mediator（中介者模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

#### Visitor（访问者模式）

> Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

#### Memento（备忘录模式）

> Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

#### State（状态模式）

> State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

#### Strategy（策略模式）

> Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。

#### Template Method（模板方法模式）

> Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

> Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

#### Command（命令模式）

> Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

#### Chain of Responsibility（职责链模式）

> Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

### 创建型

#### Singleton（单例模式）

> Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### Prototype（原型模式）

> Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

#### Builder（建造者模式）

> Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

#### Factory Method(工厂模式)

> Factory Method(工厂模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 Factory Method使一个类的实例化延迟到其子类

####  Abstract Factory（抽象工厂模式）

> Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 结构型

#### Bridge（桥接模式）

> Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

#### Facade（外观模式）

> Facade（外观模式）：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### Composite(组合模式)

> Composite(组合模式)：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。

#### Decorator(装饰模式)：

> Decorator(装饰模式)：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。

#### Adapter（适配器模式）

> Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### Proxy（代理模式）

> Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。

#### Flyweight（享元模式）

> Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。

### 模式之间关系

### 其他

### 参考资料

#### 23种设计模式UML图

## UML

> UML是一种通用的建模语言，其表达能力相当的强，不仅可以用于软件系统的建模，而且可用于业务建模以及其它非软件系统建模。UML综合了各种面向对象方法与表示法的优点，至提出之日起就受到了广泛的重视并得到了工业界的支持。

### 组成

> 视图(View)： 是表达系统的某一方面的特征的UML建模元素的子集，由多个图构成，是在某一个抽象层上，对系统的抽象表示。

> 图(Diagram)： 是模型元素集的图形表示，通常是由弧（关系）和顶点（其他模型元素）相互连接构成的

> 模型元素(Model Element)：代表面向对象中的类、对象、消息和关系等概念，是构成图的最基本的常用概念。

> 通用机制(General Mechanism)：用于表示其他信息，比如注释、模型元素的语义等。另外，UML还提供扩展机制，使UML语言能够适应一个特殊的方法（或过程），或扩充至一个组织或用户。本的常用概念。

### 架构视图分类

> (1) 用例视图(Use Case View)，强调从用户的角度看到的或需要的系统功能，是被称为参与者的外部用户所能观察到的系统功能的模型图。

> (2) 逻辑视图(Logical View)，展现系统的静态或结构组成及特征，也称为结构模型视图(Structural Model View)或静态视图(Static View)。

> (3) 并发视图(Concurrent View)，体现了系统的动态或行为特征，也称为行为模型视图(Behavioral Model View)或动态视图(Dynamic View)。

> (4) 组件视图(Component View)，体现了系统实现的结构和行为特征，也称为实现模型视图(Implementation Model View)。

> (5) 配置视图(Deployment View)，体现了系统实现环境的结构和行为特征，也称为环境模型视图(Environment Model View)或物理视图(Physical View)。

### UML视图

#### (1) 用例图(Use Case Diagram)，描述系统功能；

#### (2) 类图(Class Diagram)，描述系统的静态结构；

##### 基本元素符号：

\###### 1. 类（Classes）类（Class）是指具有相同属性、方法和关系的对象的抽象，
它封装了数据和行为，是面向对象程序设计（OOP）的基础，
具有封装性、继承性和多态性等三大特性。
在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。

￿﻿\[{"data":{"id":"cf32aswv30w0","created":1634613991376,"text":"类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。","richText":{"ops":\[{"attributes":{},"insert":"类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]
￿﻿\[{"data":{"id":"cf32aswutog0","created":1634613991376,"text":"属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示：","richText":{"ops":\[{"attributes":{},"insert":"属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示："},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

*
    1.  类名（Name）是一个字符串，例如，Student。

*   (2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：

*   \[可见性]属性名:类型\[=默认值]

*   例如：-name\:String

*   注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、\~表示。

*   (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：

*   \[可见性]名称(参数列表)\[:返回类型]

*   例如：+display()\:void。

\###### 2. 包（Package）
包可直接理解为命名空间，文件夹，是用来组织图形的封装，包图可以用来表述功能组命名空间的组织层次。

•在面向对象软件开发的视角中，类显然是构建整个系统的基本构造块。
但是对于庞大的应用系统而言，其包含的类将是成百上千，
再加上其间“阡陌交纵”的关联关系、多重性等，必然是大大超出了人们可以处理的复杂度。
这也就是引入了“包”这种分组事物构造块。

￿﻿\[{"data":{"id":"cf32aswvrh40","created":1634613991377,"text":"包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。","richText":{"ops":\[{"attributes":{},"insert":"包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

*   包的可见性：

*   用“+”来表示“public”，

*   用“#”来表示“protected”，

*   用“-”来表示“private”

\###### 3. 接口（Interface）
接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，
只可以被子类实现。它包含抽象操作，但不包含属性。
它描述了类或组件对外可见的动作。
在 UML 中，接口使用一个带有名称的小圆圈来进行表示。

￿﻿\[{"data":{"id":"cf32aswvqhc0","created":1634613991377,"text":"接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<\<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。\n","richText":{"ops":\[{"insert":"接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<\<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。\n"}]},"background":"transparent"},"children":\[]}]

##### 关　系：

\###### 1. 依赖（Dependency）

1.1.1       依赖（Dependency）:虚线箭头表示
1、依赖关系也是类与类之间的联结
2、依赖总是单向的。（#add 注意，要避免双向依赖。一般来说，不应该存在双向依赖。）
3、依赖关系在 Java 或 C++ 语言中体现为局部变量、方法的参数或者对静态方法的调用。

（软件开发中，往往会设计一些公用类，供别的类调用，如果这些公用类出问题了，那调用这些公用类的类都会因此而出问题。
两个元素之间的一种关系，其中一个元素（提供者)的变化将影响另一个元素（客体)，或向它提供所需信息
显示一个类引用另一个类）

方法参数示例：

```

public class Person
{
void buy(Car car)
{
...
}	
}

```

表示方法：虚线加箭头

特点：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。

依赖关系可以分为以下四类：
1）  使用依赖（Usage）表示客户使用提供者提供的服务以实现它的行为，包括：

使用<\<use>>--声明使用一个类时需要用到已存在的另一个类。
调用<\<call>>--声明一个类调用其他类的操作的方法。
参数<\<parameter>>--声明一个操作和它的参数之间的关系。
发送<\<send>>--声明信号发送者和信号接收者之间的关系。
实例化<\<instantiate>>--声明用一个类的方法创建了另一个类的实例。
2）  抽象依赖（Abstraction）表示客户与提供者之间用不同的方法表现同一个概念，通常一个概念更抽象，一个概念更具体。包括：

跟踪<\<trace>>--声明不同模型中的元素之间存在一些连接但不如映射精确。
精化<\<refine>>--声明具有两个不同语义层次上的元素之间的映射。
派生<\<derive>>--声明一个实例可以从另一个实例导出。
3）  授权依赖（Permission）表达提供者为客户提供某种权限以访问其内容的情形。包括：

访问<\<access>>--允许一个包访问另一个包的内容。
导入<\<import>>--允许一个包访问另一个包的内容并为被访问包的组成部分增加别名。
友元<\<friend>>--允许一个元素访问另一个元素，不管被访问的元素是否具有可见性。
4）  绑定依赖（Binding）较高级的依赖类型，用于绑定模板以创建新的模型元素，包括：

绑定<\<bind>>--为模板参数指定值，以生成一个新的模型元素。

*   依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，
    是临时性的关联。在代码中，某个类的方法通过局部变量、
    方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

\###### 2. 关联（Association）

￿﻿\[{"data":{"id":"cf32akd93z40","created":1634613972776,"text":"实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。","richText":{"ops":\[{"attributes":{},"insert":"实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

关联（Association）：实线箭头表示
1、关联关系是类与类之间的联结，它使一个类知道另一个类的属性和方法。
2、关联可以是双向的，也可以是单向的（#add还有自身关联）。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
3、在 Java 或 c++ 中，关联关系是通过使用成员变量来实现的。

```
public class 徒弟
{

}

public class 唐僧
{
protected: list<徒弟> tdlist;
}

```

表示方法：实线箭头

特征：表示类与类或类与接口之间的依赖关系，表现为“拥有关系”；具体到代码可以用实例变量来表示。（A类有一个成员变量保存的是B类的一个引用，也就是说由A类可以找到B类）

*   关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，
    如老师和学生、师傅和徒弟、丈夫和妻子等。
    关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。

关联可以是双向的，也可以是单向的。在 UML 类图中，
双向的关联可以用带两个箭头或者没有箭头的实线来表示，
单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。
也可以在关联线的两端标注角色名，代表两种不同的角色。

\###### 3. 聚合（Aggregation）

￿﻿\[{"data":{"id":"cf32akd946w0","created":1634613972776,"text":"聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。","richText":{"ops":\[{"attributes":{},"insert":"聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]
￿﻿\[{"data":{"id":"cf32akd8tag0","created":1634613972776,"text":"关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。","richText":{"ops":\[{"attributes":{},"insert":"关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

1.1.3       聚合（Aggregation）：带空心菱形头表示
1、聚合关系是关联关系的一种，是强的关联关系。
2、聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成。
3、聚合关系也是通过成员变量来实现的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分。
4、关联与聚合仅仅从 Java 或 C++ 语法上是无法分辨的，必须考察所涉及的类之间的逻辑关系。

```
public class 引擎
{

}
public class 轮胎
{

}
public class 汽车
{
protected:引擎 engine;
protected:轮胎 tyre\[4];
}

```

表示方法：空心菱形头

特征：属于是关联的特殊情况，体现部分-整体关系，是一种弱拥有关系；整体和部分可以有不一样的生命周期；是一种弱关联；

*   聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，
    是 has-a 的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，
    但是成员对象可以脱离整体对象而独立存在。
    例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

\###### 4. 合成（Composition）

￿﻿\[{"data":{"id":"cf32akd8vlk0","created":1634613972776,"text":"合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。","richText":{"ops":\[{"attributes":{},"insert":"合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]
￿﻿\[{"data":{"id":"cf32akd8s680","created":1634613972776,"text":"局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。","richText":{"ops":\[{"attributes":{},"insert":"局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

1.1.4       组合（Composition）：带实心菱形头的实线表示
1、合成关系是关联关系的一种，是比聚合关系还要强的关系。
2、它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。

    class 肢
    {
    }
    class 人
    {
    protected:  肢   limb[4];
    }

表示方法：一般是实心菱形加实线箭头表示

特征：属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；整体与部分有相同的生命周期，是一种强关联；

*   组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，
    但它是一种更强烈的聚合关系，是 cxmtains-a 关系。
    在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，
    部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

\###### 5. 泛化（Generalization）

￿﻿\[{"data":{"id":"cf32akd9luo0","created":1634613972777,"text":"泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。","richText":{"ops":\[{"attributes":{},"insert":"泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

1.1.5       泛化（Generalization）：
带空心箭头的实线线表示
泛化（下图）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。

泛化关系表示类与类之间的继承关系，接口与接口之间的继承关系。如下图：

*   泛化（Generalization）关系是对象之间耦合度最大的一种关系，
    表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。

\###### 6. 实现（Realization）

￿﻿\[{"data":{"id":"cf32akd9t1k0","created":1634613972777,"text":"实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。","richText":{"ops":\[{"attributes":{},"insert":"实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":\[]}]

1.1.6       实现（Realization）：空心箭头和虚线表示
实例（图I）关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。表达一种说明元素与实现元素之间的关系；

*   实现（Realization）关系是接口与实现类之间的关系。
    在这种关系中，类实现了接口，
    类中的操作实现了接口中所声明的所有的抽象操作。

\###### 关系之间关联与区别

1.聚合与组合

（1）聚合与组合都是一种结合关系，只是额外具有整体-部分的意涵。

（2）部件的生命周期不同

聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。
组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时间共享同一个部件。

（3）聚合关系是“has-a”关系，组合关系是“contains-a”关系。

“弱”包含表示如果部门没有了，员工也可以继续存在；
“强”包含表示如果部门没有了，员工也不再存在；
在做软件需求时，往往会将所有的包含关系画成“弱”包含，后面发现某些关系可以表示为“强”包含是，才转为实心菱形。

2.关联和聚合

（1）表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

（2）关联和聚合的区别主要在语义上，关联的两个对象之间一般是平等的，例如你是我的朋友，聚合则一般不是平等的。

（3）关联是一种结构化的关系，指一种对象和另一种对象有联系。

（4）关联和聚合是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。

3.关联和依赖

（1）关联关系中，体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。

（2）依赖关系中，可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。

4.泛化和实现

实现表示类对接口的实现关系，表示方式：用一条带有空心三角箭头的虚线指向接口。

泛化表示类与类之间的继承关系、接口与接口之间的继承关系，表示方式一条带有空心三角箭头的实线指向基类（父接口）。

5.综合比较

　　这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；但总的来说，后几种关系所表现的强弱程度依次为：

　　　　　　　　　　组合>聚合>关联>依赖

　　其中依赖（Dependency）的关系最弱，而关联（Association），聚合（Aggregation），组合（Composition）表示的关系依次增强。换言之关联，聚合，组合都是依赖关系的一种，聚合是表明对象之间的整体与部分关系的关联，而组合是表明整体与部分之间有相同生命周期关系的聚合。

而关联与依赖的关系用一句话概括下来就是，依赖描述了对象之间的调用关系，而关联描述了对象之间的结构关系。

#### (3) 对象图(Object Diagram)，描述系统在某个时刻的静态结构；

#### (4) 组件图(Component Diagram)，描述了实现系统的元素的组织；

#### (5) 配置图(Deployment Diagram)，描述了环境元素的配置，并把实现系统的元素映射到配置上；

#### (6) 状态图(State Diagram)，描述了系统元素的状态条件和响应；

#### (7) 时序图(Sequence Diagram)，按时间顺序描述系统元素间的交互；

#### (8) 协作图(Collaboration Diagram)，按照时间和空间顺序描述系统元素间的交互和它们之间的关系；

#### (9) 活动图(Activity Diagram)，描述了系统元素的活动；

#### Other

##### 包图

\###### 包图是 UML 一種用以显示包和包之间的依赖关系的结构性图表。模型图能显示系统的不同视图，例如，多层应用程序。

##### 组合结构图

\###### 组合结构图是添加到 UML 2.0 中的新的图表之一。复合结构图与类图相似，是一种用于微观视角的系统建模组件图，而不是整个类的组成部分。它是一种静态结构图，显示了一个类的内部结构和这个结构所实现的协作。

##### 轮廓图

\###### 轮廓图 使您能够创建特定于域和平台的原型，并定义它们之间的关系。

##### 序列图

\###### 序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。凭借先进的可视化建模功能，您只需点击几下即可创建复杂的顺序图。另外，Visual Paradigm 可以根据用例描述中定义的事件流生成序列图。

##### 通訊圖

\###### 与序列图类似，通訊圖也用于模拟用例的动态行为。与序列图相比，通訊圖更侧重于显示对象的协作而不是时间顺序。它们实际上在语义上是等价的，因此一些建模工具（如 Visual Paradigm）允许您从一个模型生成一个到另一个。

##### 交互概览图

\###### 交互概述图侧重于交互控制流程的概述，它是活动图的变体，其中节点是交互 (Interactions) 或交互发生 (Interaction Occurrences)。交互概述图描述了隐藏於消息 (Message) 和生命线 (Lifeline) 間的交互。

##### 时序图

\###### 时序图显示了既定时间内对象的行为。时序图是序列图的一种特殊形式，它俩之间的差异是轴反转，时间从左到右增加，生命线显示在垂直排列的独立隔间中。

##### 内部结构图

\###### 内部结构图(Internal structure diagram):显示分类器的内部结构 – 将分类器分解为其属性，部件和关系。

*   结构化类(structured class)，

*   属性类(part)，

*   端口(port)，

*   连接器(connector)，

*   作用关系(usage)。

##### 协作使用图

\###### 协作使用图(Collaboration use diagram)显示系统中的对象彼此合作以产生系统的某些行为。

*   协作(collaboration)，

*   连接器(connector)，

*   属性类(part)，

*   依赖(dependency)。

##### 表现图

表现图(Manifestation diagram):用于显示工件的组件的显化（实现）和工件的内部结构。可以把它作为组件图和部署图的补充，组件图显示组件和分类器之间的组件关系，部署图表达把工件部署到部署环境。

由于表现图不是由UML 2.5规范定义的，因此可以使用组件图或部署图来显示通过构件显示的组件。

\###### 表现形式(manifestation)，

\###### 组件(component)，

\###### 工件(artifact)。

##### 网络体系结构图

\###### 网络体系结构图(Network architecture diagram):用来显示系统的逻辑或物理网络架构的部署图 。在UML 2.5中没有正式定义。

*   节点(node)，

*   交换机(switch)，

*   路由器(router)，

*   负载均衡器(load-balancer)，

*   防火墙(firewall)，

*   通信路径(communication-path)，

*   网段(network-segment)，

*   主干网(backbone)。

##### 配置文件图

配置文件图(Profile diagram):作为UML标准的轻量级扩展机制的辅助图，它允许定义定制的原型、标记值和约束。概要文件允许对不同的UML元模型进行调整

平台（比如J2EE或.NET）或者
域（如实时或业务流程建模）。
配置图首次在UML 2.0中引入。

\###### 配置(profile)，

\###### 配置类(profile-metaclass)，

\###### 模板(stereotype)，

\###### 配置扩展(profile-extension)，

\###### 配置参考(profile-reference)，

\###### 配置应用程序(profile-application)。

##### 信息流程图

\###### 信息流图(information-flow-diagrams):显示一些高度抽象的系统实体之间的信息交换。信息流在尚未完全明确或缺少细节的情况下，显示系统信息的流转过程。

*   信息流(information-flow)，

*   信息项目(information-item)，

*   参与者(actor)，

*   类(class)。

##### 行为状态机图

\###### 行为状态机图(behavioral-state-machine)通过有限状态转换显示设计系统的一部分的离散行为。

*   行为状态(behavioral state)，

*   行为转换(behavioral transition)，

*   伪状态(pseudostate)。

##### 协议状态机图

\###### 协议状态机图(protocol state machine diagrams)：显示使用协议或某个分类器的生命周期，例如可以在分类器的每个状态下调用分类器的哪些操作，在哪些特定条件下以及在分类器转换到目标状态之后满足某些可选的后置条件。

*   协议状态(protocol state)，

*   协议转换(protocol transition)，

*   伪状态(pseudostate)。

##### 交互图

交互图(Interaction diagram)包括几种不同类型的图：

序列图(sequence diagrams)，
通信图(communication-diagrams)（在UML 1.x中称为协作图），
时序图(timing diagrams)，
交互概览图(interaction overview diagrams)。

\###### 序列图(sequence diagrams)，

*   生命线(lifeline)，

*   执行申明(execution specification)，

*   消息(message)，

*   复合片段(Combined Fragment)，

*   交互使用(interaction use)，

*   状态不变式(state invariant)，

*   销毁(Destruction Occurrence)。

\###### 通信图(communication-diagrams)（在UML 1.x中称为协作图），

*   生命线(lifeline)，

*   消息(message)。

\###### 时序图(timing diagrams)，

*   生命线(lifeline)，

*   状态或状况时间表(state or condition timeline)，

*   销毁事件(destruction event)，

*   持续约束(duration constraint)，

*   时间限制(duration constraint)。

\###### 交互概览图(interaction overview diagrams)。

*   交互概览图(interaction overview diagrams)通过一种活动图的变体定义交互，以促进控制流的概述。交互概述图侧重于交互或交互使用的控制流节点的概述 。生命线和消息不会出现在此概述中。

    *   初始节点(initial node)，

    *   流最终节点(flow final node)，

    *   活动最终节点(activity final node)，

    *   决策节点(decision node)，

    *   合并节点(merge node)，

    *   分叉节点(fork node)，

    *   连接节点(join node)，

    *   交互(interaction)，

    *   交互使用(interaction use)，

    *   持续约束(duration constraint)，

    *   时间限制(duration constraint)。

### 分类

#### 不同架构视图的应用

##### (1) 用户模型视图

> (1) 用例图(Use Case Diagram)

##### (2) 结构模型视图

> (2) 类图(Class Diagram)；

> (3) 对象图(Object Diagram)

##### (3) 行为模型视图

> (6) 状态图(State Diagram)

> (7) 时序图(Sequence Diagram)

> (8) 协作图(Collaboration Diagram)

> (9) 活动图(Activity Diagram)

##### (4) 实现模型视图

> (4) 组件图(Component Diagram)

##### (5) 环境模型视图

> (5) 配置图(Deployment Diagram)

#### 静态结构还是动态行为

##### 静态结构

> (2) 类图(Class Diagram)；

> (3) 对象图(Object Diagram)

> (4) 组件图(Component Diagram)

> (5) 配置图(Deployment Diagram)

##### 动态行为

> (1) 用例图(Use Case Diagram)

> (6) 状态图(State Diagram)

> (7) 时序图(Sequence Diagram)

> (8) 协作图(Collaboration Diagram)

> (9) 活动图(Activity Diagram)

### 4+1视图与UML视图对应

> 场景视图 use case

> 逻辑视图 类图

> 开发视图 类图，组件图

> 进程视图 无完全对应

> 部署视图 部署图

## 词汇表和术语

> 抽象类：一个永远不会被实例化的类。这个类的一个实例永远不会存在。

> Actor：发起系统参与的事件的对象或人物。

> 活动：活动图中的步骤或行动。表示系统或演员采取的行动。

> 活动图：一个美化的流程图，显示了流程中的步骤和决定以及并行操作，如算法或业务流程。

> 聚合：是另一类的一部分。图中的包含类旁边有一个空心钻石。

> 工件：描述设计过程中某个步骤输出的文档。描述是图形，文字或其他组合。

> 关联：一个模型的两个元素之间的联系。这可能代表代码中的成员变量，或者人员记录与其所代表的人之间的关联，或者两类工作人员之间的关系，或者任何类似的关系。默认情况下，一个关联中的两个元素是相等的，并且通过该关联知道对方。一个协会也可以是一个可导航的协会，这意味着协会的来源端知道目标端，但反之亦然。

> 关联类：表示两个其他类之间的关联信息的类。

> 属性：可用于引用其他对象或保存对象状态信息的对象的特征。

> 基类：定义由子类通过泛化关系继承的属性和操作的类。

> 分支：活动图中的决策点。分支出现多个转变，每个都有一个保护条件。当控制到达分支时，恰好一个保护条件必须为真; 并且控制遵循相应的转换。

> 类：类似对象的类别，全部由相同的属性和操作描述，并且所有的赋值兼容。

> 类图：显示系统类和它们之间的关系。

> 分类器 ：具有属性和操作的UML元素。具体来说，Actor，Classes和Interfaces。

> 协作：通信图中两个对象之间的关系，指示消息可以在对象之间来回传递。

> 通信图：显示如何在强调对象角色的同时完成操作的图表。

> 组件：系统中可部署的代码单元。

> 组件图：显示各种组件和接口之间关系的图表。

> 概念：要包含在域模型中的名词或抽象概念。

> 构建阶段：Rational统一过程的第三阶段，在这个阶段中，正在构建的系统中内置了多个功能迭代。这是主要工作完成的地方。

> 依赖关系：指示一个分类器的关系知道另一个分类器的属性和操作，但不直接连接到第二个分类器的任何实例。

> 部署图：显示各种处理器之间关系的图表。

> 域：系统所涉及的宇宙的一部分。

> 精化阶段：Rational统一过程的第二阶段，允许额外的项目计划，包括构建阶段的迭代。

> 元素：出现在模型中的任何项目。

> 封装：对象中的数据是私有的。

> 泛化：指示一个类是另一个类（超类）的子类。一个空心箭头指向超类。

> 事件：在状态图中，这表示导致系统采取行动或切换状态的信号或事件或输入。

> 最终状态 ：在状态图或活动图中，这表示图完成的点。

> 叉：活动图中的一个点，多个并行控制线程开始。

> 泛化：继承关系，其中一个子类继承并添加到基类的属性和操作。

> 高凝聚力：GRASP评估模式，确保课程不是太复杂，做不相关的功能。

> 低耦合：GRASP评估模式，衡量一个类别依赖于另一个类别或与另一个类别相关联。

> 启动阶段：Rational统一过程的第一阶段，处理原始概念化和项目开始阶段。

> 继承：子类继承父类（超类）类的属性或特性。这些属性可以在子类中重写。

> 初始状态：在状态图或活动图中，这表示图开始的点。

> 实例：一个类像模板一样用来创建一个对象。这个对象被称为类的一个实例。可以创建任何数量的该类的实例。

> 接口：定义形成行为契约的属性和操作的分类器。提供者类或组件可以选择实现接口（即实现其属性和操作）。客户端类或组件可以依赖于接口，并因此使用提供者而不提供提供者的真实类别的任何细节。

> 迭代：一个小项目部分，在这个小项目中，一小部分功能被添加到项目中。包括分析，设计和编码的开发循环。

> 加入：活动图中的一个点，多个并行控制线程同步并重新加入。

> 成员：分类器中的属性或操作。

> 合并：活动图中的一个点，不同的控制路径汇集在一起​​。

> 消息：从一个对象到另一个对象的请求，要求接收消息的对象执行某些操作。这基本上是对接收对象中的方法的调用。

> 方法：对象中的函数或过程。

> 模型：中央UML神器。由各个元素组成的层次结构，以及元素之间的关系。

> 多重性：显示在领域模型中，表示外部概念框，表示与其他对象的分位数的对象数量关系。

> 可导航性：指示关系的哪一端知道另一端。关系可以具有双向可导航性（每一端意识到另一端）或单向导航（一端意识到另一端，但反之亦然）。

> 符号：创建分析和设计方法的图形化文档。

> 对象：对象：在活动图中，从活动接收信息或向活动提供信息的对象。在“协作图”或“序列图”中，参与图中所示场景的对象。通常：给定分类器（Actor，Class或Interface）的一个实例或示例。

> 包：逻辑上应该组合在一起的一组UML元素。

> 包图：所有元素都是包和依赖关系的类图。

> 模式：用于确定交互对象责任分配的解决方案。这是一个成功解决众所周知的常见问题的名称。

> 参数：一个操作的参数。

> 多态性：相同的消息，不同的方法。也用作模式。

> 私有：应用于属性或操作的可见性级别，指示只有包含该成员的分类器的代码才可以访问该成员。

> 处理器：在部署图中，代表可以部署代码的计算机或其他可编程设备。

> 受保护：应用于属性或操作的可见性级别，指示只有包含该成员或其子类的分类器的代码才能访问该成员。

> 公开：应用于属性或操作的可见性级别，指示任何代码都可以访问该成员。

> 读取方向箭头：指示领域模型中关系的方向。

> 实现：表示组件或类提供给定的接口。

> 角色：用于域模型，是关于角色角色的可选描述。

> 顺序图：一个图表，显示随着时间的推移对象的存在，以及随着时间的推移在这些对象之间传递的消息来执行一些行为。状态图图 - 显示所有可能的对象状态的图。

> 状态：在状态图中，这表示系统或子系统的一种状态：它在某个时间点所做的事情，以及其数据的值。

> 状态图：显示系统或子系统的状态，状态之间的转换以及导致转换的事件的图表。

> 静态：一个属性的修饰符，用于指示分类器的所有实例之间共享的属性只有一个副本。“操作”的修饰符，用于指示“操作”独立运行并且不在分类器的一个特定实例上操作。

> 刻板印象（Stereotype）：一个应用于Model元素的修饰符，用于指示它通常不能用UML表示的东西。从本质上讲，定型允许你定义你自己的UML“方言”。

> 子类：继承由子类通过泛化关系定义的属性和操作的类。

> 互動區：活动图的一个元素，指示系统或域的哪些部分执行特定的活动。泳道内的所有活动都由泳道所代表的对象，组件或者演员负责。

> 时间拳击：每次迭代都会有特定目标的时间限制。

> 过渡：在活动图中，表示从一个活动或分支或合并或分叉或连接到另一个的控制流程。在国家图中，代表着一个国家向另一个国家的转变。

> 过渡阶段 - Rational 统一过程的最后一个阶段，在这个阶段，用户接受使用新系统和系统的培训，用户可以使用这个阶段。

> 统一建模语言（ UML）：统一建模语言（ UML）利用文本和图形文档，通过在对象之间建立更紧密的关系，来增强软件项目的分析和设计

> 用例：在用例图中，表示系统响应来自Actor的某个请求所采取的操作。

> 用例图：显示参与者和用例之间关系的图表。

> 可见性：对属性或操作的修饰符，指示哪些代码可以访问成员。可见性级别包括公共，受保护和私有。

> 工作流程：一组产生特定结果的活动。

# &#x20;微服务

**一、微服务架构介绍**  

微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。你可以将其看作是在架构层次而非获取服务的

类上应用很多SOLID原则。微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

\*\*概念：\*\*把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

\*\*定义：\*\*围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

\*\*本质：\*\*用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。

 

**二、出现和发展**

微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；

越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。

这老头是个奇人，特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点：**一解释就懂，一问就不知，一讨论就打架。**

Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首

席科学家。在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的

专家，现为Thought Works公司的首席科学家。Thought Works是一家从事企业应用开发和——集

成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几

本经典书籍： 《企业应用架构模式》、《UML精粹》和《重构》等。

                                                                                              ———— 百度百科

**三、传统开发模式和微服务的区别**

先来看看传统的web开发方式，通过对比比较容易理解什么是Microservice Architecture。和Microservice相对应的，这种方式一般被称为Monolithic（单体式开发）。

所有的功能打包在一个 WAR包里，基本没有外部依赖（除了容器），部署在一个JEE容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI等所有逻辑。

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501194151445-939262804.png)

**优点：**

①开发简单，集中式管理

②基本不会重复开发

③功能都在本地，没有分布式的管理和调用消耗

**缺点：**

1、效率低：开发都在同一个项目改代码，相互等待，冲突不断

2、维护难：代码功功能耦合在一起，新人不知道何从下手

3、不灵活：构建时间长，任何小修改都要重构整个项目，耗时

4、稳定性差：一个微小的问题，都可能导致整个应用挂掉

5、扩展性不够：无法满足高并发下的业务需求

**常见的系统架构遵循的三个标准和业务驱动力：**

1、提高敏捷性：及时响应业务需求，促进企业发展

2、提升用户体验：提升用户体验，减少用户流失

3、降低成本：降低增加产品、客户或业务方案的成本

**基于微服务架构的设计：**

\*\*目的：\*\*有效的拆分应用，实现敏捷开发和部署

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501194607023-1194438149.png)

 

 

**关于微服务的一个形象表达：**

**![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501194636867-1452154359.png)**

\*\*X轴：\*\*运行多个负载均衡器之后的运行实例

\*\*Y轴：\*\*将应用进一步分解为微服务（分库）

\*\*Z轴：\*\*大数据量时，将服务分区（分表）

 

**四、微服务的具体特征**

**官方的定义：**

1、一些列的独立的服务共同组成系统

2、单独部署，跑在自己的进程中

3、每个服务为独立的业务开发

4、分布式管理

5、非常强调隔离性

**大概的标准：**

1、分布式服务组成的系统

2、按照业务，而不是技术来划分组织

3、做有生命的产品而不是项目

4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）

5、自动化运维（ DevOps ）

6、高度容错性

7、快速演化和迭代

 

**五、SOA和微服务的区别**

**1、SOA喜欢重用，微服务喜欢重写**

**SOA**的主要目的是为了企业各个系统更加容易地融合在一起。 说到SOA不得不说ESB(EnterpriseService Bus)。 ESB是什么? 可以把ESB想象成一个连接所有企业级服务的脚手架。

通过service broker，它可以把不同数据格式或模型转成canonical格式，把XML的输入转成CSV传给legacy服务，把SOAP 1.1服务转成 SOAP 1.2等等。 它还可以把一个服务

路由到另一个服务上，也可以集中化管理业务逻辑，规则和验证等等。 它还有一个重要功能是消息队列和事件驱动的消息传递，比如把JMS服务转化成SOAP协议。 各服务间可能有

复杂的依赖关系。

**微服务**通常由重写一个模块开始。要把整个巨石型的应用重写是有很大的风险的，也不一定必要。我们向微服务迁移的时候通常从耦合度最低的模块或对扩展性要求最高的模块开始，

把它们一个一个剥离出来用敏捷地重写，可以尝试最新的技术和语言和框架，然 后单独布署。 它通常不依赖其他服务。微服务中常用的API Gateway的模式主要目的也不是重用代码，

而是减少客户端和服务间的往来。API gateway模式不等同与Facade模式，我们可以使用如future之类的调用，甚至返回不完整数据。

 

**2、SOA喜欢水平服务，微服务喜欢垂直服务**

**SOA**设计喜欢给服务分层(如Service Layers模式)。 我们常常见到一个Entity服务层的设计，美其名曰Data Access Layer。 这种设计要求所有的服务都通过这个Entity服务层

来获取数据。 这种设计非常不灵活，比如每次数据层的改动都可能影响到所有业务层的服务。 而每个微服务通常有它自己独立的data store。 我们在拆分数据库时可以适当的做些

去范式化(denormalization)，让它不需要依赖其他服务的数据。

**微服务**通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。 类似的功能可能针对手机有一个服务，针对机顶盒是另外一个服务。 在SOA设计模式中这种情况通常会用到

Multi-ChannelEndpoint的模式返回一个大而全的结果兼顾到所有的客户端的需求。

 

**3、SOA喜欢自上而下，微服务喜欢自下而上**

**SOA**架构在设计开始时会先定义好服务合同(service contract)。 它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，schema，等等。 它使用Enterprise

Inventory和Service Composition等方法来集中管理服务。 SOA架构通常会预先把每个模块服务接口都定义好。 模块系统间的通讯必须遵守这些接口，各服务是针对他们的调用者。

SOA架构适用于TOGAF之类的架构方法论。

**微服务**则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代。

 

**六、怎么具体实践微服务**

要实际的应用微服务，需要解决一下四点问题：

1、客户端如何访问这些服务

2、每个服务之间如何通信

3、如此多的服务，如何实现？

4、服务挂了，如何解决？（备份方案，应急处理机制）

**1、客户端如何访问这些服务**

原来的Monolithic方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。客户端UI如何访问他的？

后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。

另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无 状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

所以，一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括：

① 提供统一服务入口，让微服务对前台透明

② 聚合后台的服务，节省流量，提升性能

③ 提供安全，过滤，流控等API管理功能

其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。他们最重要的作 用是为前台（通常是

移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过API Gateway也有可能成为单点故障点或者性能的瓶颈。

用过Taobao Open Platform（淘宝开放平台）的就能很容易的体会，TAO就是这个API Gateway。

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501200100476-640600373.png)

 

 

**2、每个服务之间如何通信**

所有的微服务都是独立的Java进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。现在基本最通用的有两种方式：

同步调用：

①REST（JAX-RS，Spring Boot）

②RPC（Thrift, Dubbo）

异步消息调用(Kafka, Notify, MetaQ)

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501200246382-1413166815.png)

**同步和异步的区别：**

一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意 思的话题。

一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的

SDK就能调用，所以相对使用的广一些。RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个 的开发规范和统一的服务框架时，

他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。

而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的

服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要 实现幂等性，因为消息

发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的broker，如果公司内部没有技术积累，

对broker分布式管理也是一个很大的挑战。

 

**3、如此多的服务，如何实现？**

在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？

这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息

注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过ZK寻址，根据可定制算法， 找到一个服务，还可以将服务信息缓存在本地以提高性能。

当服务下线时，ZK会发通知给服务客户端。

\*\*客户端做：\*\*优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。

\*\*服务端做：\*\*优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501200704664-1368336541.png)

 

 

**4、服务挂了，如何解决**

前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，

不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。**相应的手段有很多：**

①重试机制

②限流

③熔断机制

④负载均衡

⑤降级（本地缓存）

这些方法基本都很明确通用，比如Netflix的Hystrix：<https://github.com/Netflix/Hystrix>

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501200841226-498596991.png)

 

**七、常见的设计模式和应用**

有一个图非常好的总结微服务架构需要考虑的问题，包括：

1、API Gateway

2、服务间调用

3、服务发现

4、服务容错

5、服务部署

6、数据调用

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501200932257-1866725509.png)

 

 

**六种常见的微服务架构设计模式：**

**1、聚合器微服务设计模式**

这是一种最常见也最简单的设计模式：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201000148-1677353522.png) 

聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步

发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。

 

**2、代理微服务设计模式**

这是聚合模式的一个变种，如下图所示：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201046898-281749162.png)

在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。

 

**3、链式微服务设计模式**

这种模式在接收到请求后会产生一个经过合并的响应，如下图所示：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201150117-1722000003.png)

在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。

因此，服务调用链不宜过长，以免客户端长时间等待。

 

**4、分支微服务设计模式**

这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201226507-2146929767.png)

 

 

5、**数据共享微服务设计模式**

自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。

因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201353945-1013665174.png)

在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。

 

**6、异步消息传递微服务设计模式**

虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应，如下图所示：

![](https://images2015.cnblogs.com/blog/983980/201705/983980-20170501201415054-327655979.png)

 

 

**八、优点和缺点**

**1、微服务的优点：**

\*\*关键点：\*\*复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高

**①**它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。每个服务都以RPC或消息驱动的API的

形式定义了一个明确的边界；Microservice架构模式实现了一个模块化水平。

**②**这种架构使每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术，只要该服务符合API合同。当然，大多数组织都希望避免完全无政府状态并

限制技术选择。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，

因此使用当前技术重写旧服务变得可行。

**③**Microservice架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。例如，UI团队可以执行A | B测试，并快速迭代

UI更改。Microservice架构模式使连续部署成为可能。

**④**Microservice架构模式使每个服务都可以独立调整。您可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，您可以使用最符合服务资源要求的硬件。

 

**2、微服务的缺点**

\*\*关键点（挑战）：\*\*多服务运维难度，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等

**①**一个缺点是名称本身。术语microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。

**②**微服务器的另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的进程间通信机制。此外，他们还必须编写代码来处理部分故障，

因为请求的目的地可能很慢或不可用。

**③**微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，您需要更新不同服务所拥有的多个数据库。使用分布式事务

通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。

**④**测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。

**⑤**Microservice架构模式的另一个主要挑战是实现跨越多个服务的更改。例如，我们假设您正在实施一个需要更改服务A，B和C的故事，其中A取决于B和B取决于C.在单片应用程序中，

您可以简单地更改相应的模块，整合更改，并一次性部署。相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，

然后再维修A.幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。

**⑥**部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。每个应用程序实例都配置有基础架构服务（如数据库和消息代理）

的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。此外，您还需要实现服务

发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。传统的基于故障单和手动操作的方法无法扩展到这种复杂程度。因此，成功部署微服务应用程序需要

开发人员更好地控制部署方法，并实现高水平的自动化。

 

**九、思考：意识的转变**

微服务对我们的思考，更多的是思维上的转变。对于微服务架构：**技术上不是问题，意识比工具重要。**

关于微服务的几点设计出发点：

1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）

2、做有生命的产品，而不是项目

3、头狼战队，全栈化

4、后台服务贯彻Single Responsibility Principle（单一职责原则）

5、VM->Docker （to PE）

6、DevOps (to PE)

同时，对于开发同学，有这么多的中间件和强大的PE支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务？

最后，一般提到微服务都离不开DevOps和Docker，理解**微服务架构是核心，devops和docker是工具，是手段。**

# DDD

## 微服务和DDD的渊源

那进入微服务架构时代以后，微服务确实也解决了原来采用集中式架构的单体应用的很多问题，比如扩展性、弹性伸缩能力、小规模团队的敏捷开发等等。

**微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？**

2004年埃里克·埃文斯（Eric Evans）发表了《领域驱动设计》（Domain-Driven Design –Tackling Complexity in the Heart of Software）这本书，从此领域驱动设计（Domain Driven Design，简称DDD）诞生。DDD核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。

但DDD提出后在软件开发领域一直都是“雷声大，雨点小”！直到Martin Fowler提出微服务架构，DDD才真正迎来了自己的时代。

**利用DDD设计方法来建立领域模型，划分领域边界，再根据这些领域边界从业务视角来划分微服务边界。而按照DDD方法设计出的微服务的业务和应用边界都非常合理，可以很好地实现微服务内部和外部的“高内聚、低耦合”。**

现在，很多大型互联网企业已经将DDD设计方法作为微服务的主流设计方法了。DDD也开始真正火爆起来。

### **为什么DDD适合微服务**

**DDD是一种处理**高度复杂**领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。**

**DDD包括战略设计和战术设计两部分。**

**战略设计:主要从**业务视角**出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。**

**战术设计:则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。**

我们不妨来看看DDD是如何进行战略设计的。

DDD战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。

**事件风暴**是建立领域模型的主要方法，它是一个从发散到收敛的过程。

它通常采用**用例分析、场景分析和用户旅程分析**，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。

![](https://pic2.zhimg.com/80/v2-5e1596fd24aa79f3ccf103d847d94461_720w.webp)

**我们可以用三步来划定领域模型和微服务的边界。**

战略设计主要包括三步：

1.  通过事件风暴梳理业务过程中的要素，确定领域实体等领域对象。
2.  根据领域实体之间的业务关联性，将业务紧密相关的实体组合形成聚合。
3.  根据业务和语义边界等因素，将一个或多个聚合划定在一个限界上下文内，形成领域模型。

战术设计的主要工作是将领域模型中的领域对象与代码模型中的代码对象建立映射关系，并调整业务架构和领域模型以响应业务变化。最终，将系统架构与业务架构绑定，建立新的映射关系。

### DDD与微服务的关系

DDD主要关注：从**业务**领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。

**总体来说：**

1.  DDD是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的标准设计过程，使得你的设计思路能够更加清晰，设计过程更加规范。
2.  DDD善于处理与领域相关的拥有高复杂度业务的产品开发，通过它可以建立一个核心而稳定的领域模型，有利于领域知识的传递与传承。
3.  DDD强调团队与领域专家的合作，能够帮助你的团队建立一个沟通良好的氛围，构建一致的架构体系。
4.  DDD的设计思想、原则与模式有助于提高你的架构设计能力。
5.  无论是在新项目中设计微服务，还是将系统从单体架构演进到微服务，都可以遵循DDD的架构原则。
6.  **DDD不仅适用于微服务，也适用于传统的单体应用**。

## 关键概念

### 领域和子域Domain

我们先看一下汉语词典中对领域的解释：“领域是从事一种专门活动或事业的**范围**、部类或部门。”百度百科对领域的解释：“领域具体指一种特定的**范围**或区域。”

领域就是用来确定范围的，**范围即边界**，这也是DDD在设计中不断强调边界的原因。

既然领域是用来限定业务边界和范围的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。

领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个**子域对应一个更小的问题域或更小的业务范围**。

![](https://pic2.zhimg.com/80/v2-fee0f6e9f9855c4870e90aa8b6e29919_720w.webp)

我们来看一下上面这张图。这个例子是在讲如何给桃树建立一个完整的生物学知识体系。初中生物课其实早就告诉我们研究方法了。**它的研究过程是这样的。**

第一步：确定研究对象，即研究**领域**，这里是一棵桃树。

第二步：对研究对象进行细分，将桃树细分为器官，器官又分为营养器官和生殖器官两种。其中营养器官包括根、茎和叶，生殖器官包括花、果实和种子。桃树的知识体系是我们已经确定要研究的问题域，对应DDD的领域。根、茎、叶、花、果实和种子等器官则是细分后的问题子域。这个过程就是DDD将领域细分为多个**子域**的过程。

第三步：对器官进行细分，将器官细分为组织。比如，叶子器官可细分为保护组织、营养组织和输导组织等。这个过程就是DDD将子域进一步细分为多个**子域**的过程。

第四步：对组织进行细分，将组织细分为细胞，细胞成为我们研究的最小单元。细胞之间的细胞壁确定了单元的边界，也确定了研究的**最小边界**。

第五步：细胞核、线粒体、细胞膜等物质共同构成细胞，这些物质一起协作让细胞具有这类细胞特定的生物功能。在这里你可以把细胞理解为DDD的**聚合**，细胞内的这些物质就可以理解为聚合里面的**聚合根、实体以及值对象**等，在聚合内这些实体一起协作完成特定的业务功能。这个过程类似DDD设计时，确定微服务内功能要素和边界的过程。

### 核心域，通用域和支撑域

在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。

**决定产品和公司核心竞争力的子域是核心域**，它是业务成功的主要因素和公司的核心竞争力。

没有太多个性化的诉求，同时**被多个子域使用的通用功能子域是通用域**。

还有一种功能子域是必需的，**但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域**。

这三类子域相较之下，核心域是最重要的。

通用域和支撑域如果对应到企业系统，举例来说的话，通用域则是你需要用到的通用系统，比如认证、权限、短信等等，这类应用很容易买到，没有企业特点限制，不需要做太多的定制化。

而支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典，站内信等系统。

**那为什么要划分核心域、通用域和支撑域，主要目的是什么呢？**

**要事为先**

公司在IT系统建设过程中，由于预算和资源有限，对不同类型的子域应有不同的关注度和资源投入策略，记住好钢要用在刀刃上。

很多公司的业务，表面看上去相似，但商业模式和战略方向是存在很大差异的，因此公司的关注点会不一样，在划分核心域、通用域和支撑域时，其结果也会出现非常大的差异。

比如同样都是电商平台的淘宝、天猫、京东和苏宁易购，他们的商业模式是不同的。淘宝是C2C网站，个人卖家对个人买家，而天猫、京东和苏宁易购则是B2C网站，是公司卖家对个人买家。即便是苏宁易购与京东都是B2C的模式，他们的商业模式也是不一样的，苏宁易购是典型的传统线下卖场转型成为电商，京东则是直营加部分平台模式。

**商业模式的不同会导致核心域划分结果的不同。有的公司核心域可能在客户服务，有的可能在产品质量，有的可能在物流**。在公司领域细分、建立领域模型和系统建设时，我们就要结合公司战略重点和商业模式，找到核心域了，且重点关注核心域。

### 通用语言

在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。也就是说，**通用语言是团队统一的语言**，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。

通用语言的价值也就很明了了，它可以**解决交流障碍这个问题**，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。

但是，对这个概念的理解，到这里还不够。

**通用语言包含术语和用例场景**，并且能够直接反映在代码中。通用语言中的**名词可以给领域对象命名**，如商品、订单等，对应实体对象；而**动词则表示一个动作或事件**，如商品已下单、订单已付款等，对应领域事件或者命令。

通用语言贯穿DDD的整个设计过程。作为项目团队沟通和协商形成的统一语言，基于它，你就能够开发出可读性更好的代码，将业务需求准确转化为代码设计。

这张图描述了从事件风暴建立通用语言到领域对象设计和代码落地的完整过程。

![](https://pic2.zhimg.com/80/v2-29e97f2b8b88c520d2e433822b5427ad_720w.webp)

简单来说，通用语言确定了项目团队内部交流的统一语言，而这个语言所在的语义环境则是由限界上下文来限定的，以确保语义的唯一性。

### 限界上下文BoundedContext

我们可以将限界上下文拆解为两个词：**限界和上下文。限界就是领域的边界，而上下文则是语义环境**。通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流。

综合一下，我认为限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。

领域专家、架构师和开发人员的主要工作就是通过事件风暴来划分限界上下文。限界上下文确定了微服务的设计和拆分方向，是微服务设计和拆分的主要依据。如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。

### **实体Entity**

我们先来看一下实体是什么东西？

在DDD中有这样一类对象，**它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致**。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。

1\. 实体的业务形态

在DDD不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，**实体和值对象是组成领域模型的基础单元。**

2\. 实体的代码形态

在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。在DDD里，这些实体类通常采用**充血模型**，与这个实体相关的所有业务逻辑都在实体类的方法中实现，**跨多个实体的领域逻辑则在领域服务中实现**。

3\. 实体的运行形态

实体以DO（领域对象）的形式存在，**每个实体对象都有唯一的ID**。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品ID来标识，不管这个商品的数据如何变化，商品的ID一直保持不变，它始终是同一个商品。

4\. 实体的数据库形态

与传统数据模型设计优先不同，**DDD是先构建领域模型**，针对实际业务场景构建实体对象和行为，再将实体对象映射到数据持久化对象。

在领域模型映射到数据模型时，一个实体可能对应0个、1个或者多个数据库持久化对象。**大多数情况下实体与持久化对象是一对一**。在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。

而在有些复杂场景下，实体与持久化对象则可能是一对多或者多对一的关系。比如，用户user与角色role两个持久化对象可生成权限实体，一个实体对应两个持久化对象，这是一对多的场景。再比如，有些场景为了避免数据库的联表查询，提升系统性能，会将客户信息customer和账户信息account两类数据保存到同一张数据库表中，客户和账户两个实体可根据需要从一个持久化对象中生成，这就是多对一的场景。

## 贫血模型（Anemia Model）和充血模型（Congestion Model）

贫血模型（Anemia Model）和充血模型（Congestion Model）是DDD（Domain-Driven Design）中两种描述领域模型的状态的概念。

贫血模型是指在DDD中，将领域模型的数据和该数据的处理方法分离开来的一种方式。在贫血模型中，领域模型仅包含数据结构和对数据进行基本操作的方法，所有的业务逻辑都被放置在领域服务（Domain Service）中。这样做的目的是为了尽量保持领域模型的纯粹性，使其只关注数据和基本的操作，而将复杂的业务逻辑交由领域服务处理。

充血模型是指在DDD中，将领域模型既包含数据结构，又包含处理数据的业务逻辑的方法。在充血模型中，领域模型具有丰富的行为和能力，能够自行处理自己的业务逻辑，同时也处理与其他领域模型之间的交互。这样做的目的是为了使领域模型能够自包含地处理复杂的业务场景，减少对其他外部组件的依赖。

两种模型各有优缺点，贫血模型强调领域服务的重要性，将业务逻辑聚集在一起，但可能导致领域模型被瘦身过度。而充血模型则更加注重领域模型的自主性，但也可能导致领域模型过于臃肿和复杂。选择哪种模型取决于具体的业务需求和设计团队的喜好和背景。

### **值对象ValueObject**

《实现领域驱动设计》一书中对值对象的定义：**通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在DDD中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。**

值对象描述了领域中的一件东西，这个东西是**不可变的**，它将不同的相关属性组合成了一个概念整体。当度量和描述改变时，可以用另外一个值对象予以替换。它可以和其它值对象进行相等性比较，且不会对协作对象造成副作用。这部分在后面讲“值对象的运行形态”时还会有例子。

**简单来说就是一堆不可变的属性的集合，为了避免属性的零碎**

![](https://pic3.zhimg.com/80/v2-c8f654bb23ce097a17f907c284e16d8e_720w.webp)

人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了。

1\. 值对象的业务形态

值对象是DDD领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合。

我们不妨对照实体，来看值对象的业务形态，这样更好理解。本质上，实体是看得到、摸得着的实实在在的业务对象，**实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合**，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。

在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典。

2\. 值对象的代码形态

值对象在代码中有这样两种形态。**如果值对象是单一属性，则直接定义为实体类的属性；如果值对象是属性集合，则把它设计为Class类**，Class将具有整体概念的多个属性归集到属性集合，这样的值对象没有ID，会被实体整体引用。

我们看一下下面这段代码，person这个实体有若干个单一属性的值对象，比如Id、name等属性；同时它也包含多个属性的值对象，比如地址address。

![](https://pic1.zhimg.com/80/v2-5867d4843a472b52c565c104fff1b78c_720w.webp)

3\. 值对象的运行形态

实体实例化后的DO对象的业务属性和业务行为非常丰富，但值对象实例化的对象则相对简单和乏味。除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了。

值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌入的方式和序列化大对象的方式。

引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。比如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。

案例1：以属性嵌入的方式形成的人员实体对象，地址值对象直接以属性值嵌入人员实体中。

![](https://pic2.zhimg.com/80/v2-7517f199ce378c0aa8124c3c3a107c05_720w.webp)

案例2：以序列化大对象的方式形成的人员实体对象，地址值对象被序列化成大对象Json串后，嵌入人员实体中。

![](https://pic2.zhimg.com/80/v2-f6d809d8330dd2de9042ea983b973351_720w.webp)

4\. 值对象的数据库形态

DDD引入值对象是希望实现从“数据建模为中心”向“领域建模为中心”转变，减少数据库表的数量和表与表之间复杂的依赖关系，尽可能地简化数据库设计，提升数据库性能。

如何理解用值对象来简化数据库设计呢？

传统的数据建模大多是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独的一列来存储，一个实体主表会对应N个实体从表。而值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，**值对象的属性值和实体对象的属性值保存在同一个数据库实体表中**。

举个例子，还是基于上述人员和地址那个场景，实体和数据模型设计通常有两种解决方案：

第一是把地址值对象的所有属性都放到人员实体表中，创建人员实体，创建人员数据表；

第二是创建人员和地址两个实体，同时创建人员和地址两张表。

第一个方案会破坏地址的业务涵义和概念完整性，第二个方案增加了不必要的实体和表，需要处理多个实体和表的关系，从而增加了数据库设计的复杂性。

**那到底应该怎样设计，才能让业务含义清楚，同时又不让数据库变得复杂呢？**

在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。

要想发挥对象的威力，就需要优先做领域建模，弱化数据库的作用，**只把数据库作为一个保存数据的仓库即可**。即使违反数据库设计原则，也不用大惊小怪，只要业务能够顺利运行，就没什么关系。

## 聚合根AggregateRoot

聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。

**如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。**

首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。

其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。

最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。

## 聚合Aggregate

在DDD中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力。

举个例子。社会是由一个个的个体组成的，象征着我们每一个人。随着社会的发展，慢慢出现了社团、机构、部门等组织，我们开始从个人变成了组织的一员，大家可以协同一致的工作，朝着一个最大的目标前进，发挥出更大的力量。

领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。

**聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的**，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。

聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。按照这种方式设计出来的微服务很自然就是“高内聚、低耦合”的。

**聚合在DDD分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚**。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同一个聚合的A和B两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现；而有的业务逻辑需要聚合C和聚合D中的两个服务共同完成，这时你就可以用应用服务来组合这两个服务。

怎样设计聚合？

DDD领域建模通常采用事件风暴，它通常采用**用例分析、场景分析和用户旅程**分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合。

下面我们以保险的投保业务场景为例，看一下聚合的构建过程主要都包括哪些步骤。

![](https://pic3.zhimg.com/80/v2-e9d0c10b12fa5c8714c519e6dc49f53a_720w.webp)

**第 1 步：采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的**实体和值对象，比如投保单、标的、客户、被保人等等。

\*\*第 2 步：\*\*从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。

\*\*第 3 步：\*\*根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出 1 个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚合。在图中我们构建了客户和投保这两个聚合。

\*\*第 4 步：\*\*在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。这里我需要说明一下：投保人和被保人的数据，是通过关联客户ID从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。

\*\*第 5 步：\*\*多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。

这就是一个聚合诞生的完整过程了。

聚合的一些设计原则

《实现领域驱动设计》一书中对聚合设计原则的描述

\*\*1. 在一致性边界内建模真正的不变条件。\*\*聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。

\*\*2. 设计小聚合。\*\*如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。

\*\*3. 通过唯一标识引用其它聚合。\*\*聚合之间是通过关联外部聚合根ID的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。

\*\*4. 在边界之外使用最终一致性。\*\*聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦。

\*\*5. 通过应用层实现跨聚合的服务调用。\*\*为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。

**原则需要消化吸收后灵活运用到自己的系统中才能产生威力**

### 领域事件

领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。

举例来说的话

领域事件可以是业务流程的一个步骤，比如投保业务缴费完成后，触发投保单转保单的动作；

也可能是定时批处理过程中发生的事件，比如批处理生成季缴保费通知单，触发发送缴费邮件通知操作；

或者一个事件发生后触发的后续动作，比如密码连续输错三次，触发锁定账户的动作。

**那如何识别领域事件呢？**

很简单，和刚才讲的定义是强关联的。在做用户旅程或者场景分析时，我们要捕捉业务、需求人员或领域专家口中的关键词：“**如果发生……，则……”“当做完……的时候，请通知……”“发生……时，则……”等。在这些场景中，如果发生某种事件后，会触发进一步的操作，那么这个事件很可能就是领域事件**。

**领域事件总体架构**

领域事件的执行需要一系列的组件和技术来支撑。

领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等。下面我们逐一讲一下。

![](https://pic1.zhimg.com/80/v2-92e784efe8517bf9de20ee8be3685bfc_720w.webp)

1\. 事件构建和发布

事件基本属性至少包括：**事件唯一标识、发生时间、事件类型和事件源**，其中事件唯一标识应该是全局唯一的，以便事件能够无歧义地在多个限界上下文中传递。事件基本属性主要记录事件自身以及事件发生背景的数据。

另外事件中还有一项更重要，那就是业务属性，用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。

事件基本属性和业务属性一起构成事件实体，事件实体依赖聚合根。领域事件发生后，事件中的业务数据不再修改，因此业务数据可以以序列化值对象的形式保存，这种存储格式在消息中间件中也比较容易解析和获取。

为了保证事件结构的统一，我们还会创建事件基类 DomainEvent（参考下图），子类可以扩充属性和方法。由于事件没有太多的业务行为，实现方法一般比较简单。

![](https://pic3.zhimg.com/80/v2-7505cd9c571a61565292513f74e83fba_720w.webp)

事件发布之前需要先构建事件实体并持久化。事件发布的方式有很多种，你可以通过应用服务或者领域服务发布到事件总线或者消息中间件，也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据，发布到消息中间件。

2\. 事件数据持久化

事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。

事件数据持久化有两种方案，在实施过程中你可以根据自己的业务场景进行选择。

*   持久化到本地业务数据库的事件表中，利用本地事务保证业务和事件数据的一致性。
*   持久化到共享的事件数据库中。这里需要注意的是：业务数据库和事件数据库不在一个数据库中，它们的数据持久化操作会跨数据库，因此需要分布式事务机制来保证业务和事件数据的强一致性，结果就是会对系统性能造成一定的影响。

3\. 事件总线(EventBus)

事件总线是实现微服务内聚合之间领域事件的重要组件，它提供事件分发和接收等服务。事件总线是进程内模型，它会在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据。事件分发流程大致如下：

*   如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；
*   如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件；
*   如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件。

4\. 消息中间件

跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。消息中间件的产品非常成熟，市场上可选的技术也非常多，比如Kafka，RabbitMQ等。

5\. 事件接收和处理

微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现。

领域事件运行机制案例

承保业务流程的缴费通知单事件，来给你解释一下领域事件的运行机制。这个领域事件发生在投保和收款微服务之间。发生的领域事件是：缴费通知单已生成。下一步的业务操作是：缴费。

![](https://pic2.zhimg.com/80/v2-35dab246cd1af88d6f54507959b49edd_720w.webp)

**事件起点：出单员生成投保单，核保通过后，发起生成缴费通知单的操作。**

1.投保微服务应用服务，调用聚合中的领域服务createPaymentNotice和createPaymentNoticeEvent，分别创建缴费通知单、缴费通知单事件。其中缴费通知单事件类PaymentNoticeEvent继承基类DomainEvent。

2.利用仓储服务持久化缴费通知单相关的业务和事件数据。为了避免分布式事务，这些业务和事件数据都持久化到本地投保微服务数据库中。

3.通过数据库日志捕获技术或者定时程序，从数据库事件表中获取事件增量数据，发布到消息中间件。这里说明：事件发布也可以通过应用服务或者领域服务完成发布。

4.收款微服务在应用层从消息中间件订阅缴费通知单事件消息主题，监听并获取事件数据后，应用服务调用领域层的领域服务将事件数据持久化到本地数据库中。

5.收款微服务调用领域层的领域服务PayPremium，完成缴费。

6.事件结束。

### 事件风暴

事件风暴需要准备些什么

1\. 事件风暴的参与者

除了领域专家(对业务极其了解的人)，事件风暴的其他参与者可以是DDD专家、架构师、产品经理、项目经理、开发人员和测试人员等项目团队成员。

领域建模是统一团队语言的过程，因此项目团队应尽早地参与到领域建模中，这样才能高效建立起团队的通用语言。到了微服务建设时，领域模型也更容易和系统架构保持一致。

2\. 事件风暴要准备的材料

在这个过程中，我们要用不同颜色的贴纸区分领域行为。如下图，

*   用蓝色表示命令
*   用绿色表示实体
*   橙色表示领域事件
*   黄色表示补充信息（补充信息主要用来说明注意事项，比如外部依赖等。）

![](https://pic4.zhimg.com/80/v2-b3db7e4244ae92e7193f5c5c27ecd14b_720w.webp)

3\. 事件风暴的场地

事件风暴的发明者曾经建议要准备八米长的墙，这样设计就不会受到空间的限制了。当然，这个不是必要条件，看各自的现实条件吧，不要让思维受限就好。

或者是一个多人在线协作的白板。

4\. 事件风暴分析的关注点

在领域建模的过程中，我们需要重点关注这类业务的语言和行为。比如某些业务动作或行为（事件）是否会触发下一个业务动作，这个动作（事件）的输入和输出是什么？是谁（实体）发出的什么动作（命令），触发了这个动作（事件）…我们可以从这些暗藏的词汇中，分析出领域模型中的事件、命令和实体等领域对象。

如何用事件风暴构建领域模型

领域建模的过程主要包括产品愿景、业务场景分析、领域建模和微服务拆分与设计这几个重要阶段。下面以用户中台为例，介绍一下如何用事件风暴构建领域模型。

1\. 产品愿景

产品愿景的主要目的是对产品顶层价值的设计，使产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。

产品愿景的参与角色：领域专家、业务需求方、产品经理、项目经理和开发经理。

在建模之前，项目团队要思考这样两点：

*   用户中台到底能够做什么？
*   它的业务范围、目标用户、核心价值和愿景，与其它同类产品的差异和优势在哪里？

这个过程也是明确用户中台建设方向和统一团队思想的过程。参与者要对每一个点（下图最左侧列的内容）发表意见，用水笔写在贴纸上，贴在黄色贴纸的位置。这个过程会让参与者充分发表意见，最后会将发散的意见统一为通用语言。如果你的团队的产品愿景和目标已经很清晰了，那这个步骤你可以忽略。

2\. 业务场景分析

场景分析是从用户视角出发的，根据业务流程或**用户旅程，采用用例和场景分析**，探索领域中的典型场景，找出领域事件、实体和命令等领域对象，支撑领域建模。事件风暴参与者要尽可能地遍历所有业务细节，充分发表意见，不要遗漏业务要点。

场景分析的参与角色：领域专家、产品经理、需求分析人员、架构师、项目经理、开发经理和测试经理。

用户中台有这样三个典型的业务场景：

*   第一个是系统和岗位设置，设置系统中岗位的菜单权限；
*   第二个是用户权限配置，为用户建立账户和密码，设置用户岗位；
*   第三个是用户登录系统和权限校验，生成用户登录和操作日志。

我们可以按照业务流程，一步一步搜寻用户业务流程中的关键领域事件，比如岗位已创建，用户已创建等事件。再找出什么行为会引起这些领域事件，这些行为可能是一个或若干个命令组合在一起产生的，比如创建用户时，第一个命令是从公司HR系统中获取用户信息，第二个命令是根据HR的员工信息在用户中台创建用户，创建完用户后就会产生用户已创建的领域事件。当然这个领域事件可能会触发下一步的操作，比如发布到邮件系统通知用户已创建，但也可能到此就结束了，你需要根据具体情况来分析是否还有下一步的操作。

![](https://pic4.zhimg.com/80/v2-cbca9cbd6c53f56bc7584c3bb338a12f_720w.webp)

3\. 领域建模

领域建模时，我们会根据场景分析过程中产生的领域对象，比如命令、事件等之间关系，找出产生命令的实体，分析实体之间的依赖关系组成聚合，为聚合划定限界上下文，建立领域模型以及模型之间的依赖。领域模型利用限界上下文向上可以指导微服务设计，通过聚合向下可以指导聚合根、实体和值对象的设计。

领域建模的参与角色：领域专家、产品经理、需求分析人员、架构师、项目经理、开发经理和测试经理。

具体可以分为这样三步。

第一步：从命令和事件中提取产生这些行为的实体。用绿色贴纸表示实体。通过分析用户中台的命令和事件等行为数据，提取了产生这些行为的用户、账户、认证票据、系统、菜单、岗位和用户日志七个实体。

![](https://pic3.zhimg.com/80/v2-2555b97b0ec4e267f08165a30041d2d2_720w.webp)

第二步：根据聚合根的管理性质从七个实体中找出聚合根，比如，用户管理用户相关实体以及值对象，系统可以管理与系统相关的菜单等实体等，可以找出用户和系统等聚合根。然后根据业务依赖和业务内聚原则，将聚合根以及它关联的实体和值对象组合为聚合，比如系统和菜单实体可以组合为“系统功能”聚合。按照上述方法，用户中台就有了系统功能、岗位、用户信息、用户日志、账户和认证票据六个聚合。

第三步：划定限界上下文，根据上下文语义将聚合归类。根据用户域的上下文语境，用户基本信息和用户日志信息这两个聚合共同构成用户信息域，分别管理用户基本信息、用户登录和操作日志。认证票据和账户这两个聚合共同构成认证域，分别实现不同方式的登录和认证。系统功能和岗位这两个聚合共同构成权限域，分别实现系统和菜单管理以及系统的岗位配置。根据业务边界，我们可以将用户中台划分为三个限界上下文：用户信息、认证和权限。

![](https://pic1.zhimg.com/80/v2-9e5a4aca64021719b72635686d2586d0_720w.webp)

到这里我们就完成了用户中台领域模型的构建了。那由于领域建模的过程中产生的领域对象实在太多了，我们可以借助表格来记录。

![](https://pic2.zhimg.com/80/v2-15bb55af775912fb939d4521d89b363d_720w.webp)

4\. 微服务拆分与设计

我们在基础篇讲过，原则上一个领域模型就可以设计为一个微服务，但由于领域建模时只考虑了业务因素，没有考虑微服务落地时的技术、团队以及运行环境等非业务因素，因此在微服务拆分与设计时，我们不能简单地将领域模型作为拆分微服务的唯一标准，它只能作为微服务拆分的一个重要依据。

**一般来说一个限界上下文拆分成一个微服务**

微服务的设计还需要考虑服务的粒度、分层、边界划分、依赖关系和集成关系。除了考虑业务职责单一外，我们还需要考虑将敏态与稳态业务的分离、非功能性需求（如弹性伸缩要求、安全性等要求）、团队组织和沟通效率、软件包大小以及技术异构等非业务因素。

微服务设计建议参与的角色：领域专家、产品经理、需求分析人员、架构师、项目经理、开发经理和测试经理。

用户中台微服务设计如果不考虑非业务因素，我们完全可以按照领域模型与微服务一对一的关系来设计，将用户中台设计为：用户、认证和权限三个微服务。但如果用户日志数据量巨大，大到需要采用大数据技术来实现，这时用户信息聚合与用户日志聚合就会有技术异构。虽然在领域建模时，我们将他们放在一个了领域模型内，但如果考虑技术异构，这两个聚合就不适合放到同一个微服务里了。我们可以以聚合作为拆分单位，将用户基本信息管理和用户日志管理拆分为两个技术异构的微服务，分别用不同的技术来实现它们。

### 分层架构

DDD分层架构

DDD的分层架构在不断发展。最早是传统的四层架构；后来四层架构有了进一步的优化，实现了各层对基础层的解耦；再后来领域层和应用层之间增加了上下文环境（Context）层，五层架构（DCI）就此形成了。

![](https://pic4.zhimg.com/80/v2-981cce483c2236570f168013b364a457_720w.webp)

我们看一下上面这张图，在最早的传统四层架构中，基础层是被其它层依赖的，它位于最核心的位置，那按照分层架构的思想，它应该就是核心，但实际上领域层才是软件的核心，所以这种依赖是有问题的。后来我们采用了依赖倒置（Dependency inversion principle,DIP）的设计，优化了传统的四层架构，实现了各层对基础层的解耦。

我们今天讲的DDD分层架构就是优化后的四层架构。在下面这张图中，从上到下依次是：用户接口层、应用层、领域层和基础层。那DDD各层的主要职责是什么呢？下面我来逐一介绍一下。

![](https://pic1.zhimg.com/80/v2-ad5cd2ece6ace9d627a1c7263b59b1bc_720w.webp)

1.**用户接口层**

用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。

2.**应用层**

应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。

此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。

这里我要提醒你一下：在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。因为庞大的应用层会使领域模型失焦，时间一长你的微服务就会演化为传统的三层架构，业务逻辑会变得混乱。

另外，应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过API网关向前端发布。还有，应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。

3.**领域层**

领域层的作用是实现**企业核心业务逻辑**，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。

领域层包含**聚合根、实体、值对象、领域服务**等领域模型中的领域对象。

这里我要特别解释一下其中几个领域对象的关系，以便你在设计领域层的时候能更加清楚。

首先，领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能。

其次，你要知道，实体和领域服务在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。

4.**基础层**

基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括**第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库**等。比较常见的功能还是提供数据库持久化。

基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。

比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。

DDD分层架构最重要的原则

在《实现领域驱动设计》一书中，DDD分层架构有一个重要的原则：**每层只能与位于其下方的层发生耦合**。

而架构根据耦合的紧密程度又可以分为两种：严格分层架构和松散分层架构。优化后的DDD分层架构模型就属于严格分层架构，任何层只能对位于其直接下方的层产生依赖。而传统的DDD分层架构则属于松散分层架构，它允许某层与其任意下方的层发生依赖。

建议采用严格分层架构。

在严格分层架构中，领域服务只能被应用服务调用，而应用服务只能被用户接口层调用，服务是逐层对外封装或组合的，依赖关系清晰。而在松散分层架构中，领域服务可以同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理，甚至容易使核心业务逻辑外泄。

试想下，如果领域层中的某个服务发生了重大变更，那该如何通知所有调用方同步调整和升级呢？但在严格分层架构中，你只需要逐层通知上层服务就可以了。

### 代码架构

整洁架构

整洁架构又名“**洋葱架构**”。为什么叫它洋葱架构？看看下面这张图你就明白了。整洁架构的层就像洋葱片一样，它体现了分层的设计思想。

在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。

整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。

![](https://pic3.zhimg.com/80/v2-609df880586221ae460a41dd887885a2_720w.webp)

在洋葱架构中，各层的职能是这样划分的：

*   领域模型实现领域内核心业务逻辑，它封装了企业级的业务规则。领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。
*   领域服务实现涉及多个实体的复杂业务逻辑。
*   应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。
*   最外层主要提供适配的能力，适配能力分为主动适配和被动适配。主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。
*   红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。

六边形架构

**六边形架构又名“端口适配器架构”**。追溯微服务架构的渊源，一般都会涉及到六边形架构。

六边形架构的核心理念是：**应用是通过端口与外部进行交互的**。我想这也是微服务架构下API网关盛行的主要原因吧。

也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括APP、Web应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。

![](https://pic1.zhimg.com/80/v2-98e9fa7de1c0bad5b70b5f7797fd8cd4_720w.webp)

六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：

*   红圈内的六边形实现应用的核心业务逻辑；
*   外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以API主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。

六边形架构的一个端口可能对应多个外部系统，不同的外部系统也可能会使用不同的适配器，由适配器负责协议转换。这就使得应用程序能够以一致的方式被用户、程序、自动化测试和批处理脚本使用。

三种模型对比

虽然DDD分层架构、整洁架构、六边形架构的架构模型表现形式不一样，但你不要被它们的表象所迷惑，这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现，而它们身上闪耀的正是以领域模型为中心的设计思想。

![](https://pic4.zhimg.com/80/v2-d969bd149a25202d54a59fbd9f8fe377_720w.webp)

我们看下上面这张图，结合图示对这三种架构模型做一个分析。

请你重点关注图中的红色线框，它们是非常重要的分界线，这三种架构里面都有，它的作用就是将核心业务逻辑与外部应用、基础资源进行隔离。

红色框内部主要实现核心业务逻辑，但核心业务逻辑也是有差异的，有的业务逻辑属于领域模型的能力，有的则属于面向用户的用例和流程编排能力。按照这种功能的差异，我们在这三种架构中划分了应用层和领域层，来承担不同的业务逻辑。

领域层实现面向领域模型，实现领域模型的核心业务逻辑，属于原子模型，它需要保持领域模型和业务逻辑的稳定，对外提供稳定的细粒度的领域服务，所以它处于架构的核心位置。

应用层实现面向用户操作相关的用例和流程，对外提供粗粒度的API服务。它就像一个齿轮一样进行前台应用和领域层的适配，接收前台需求，随时做出响应和调整，尽量避免将前台需求传导到领域层。应用层作为配速齿轮则位于前台应用和领域层之间。

### **COLA4.0**

GitHub：[https://github.com/alibaba/COLA](https://link.zhihu.com/?target=https%3A//github.com/alibaba/COLA) 作者博客：[https://blog.csdn.net/significantfrank/article/details/110934799](https://link.zhihu.com/?target=https%3A//blog.csdn.net/significantfrank/article/details/110934799)

生成器：[https://start.aliyun.com/bootstrap.html](https://link.zhihu.com/?target=https%3A//start.aliyun.com/bootstrap.html)

![](https://pic2.zhimg.com/80/v2-b85246cd404419272b298de8cd1698dd_720w.webp)

![](https://pic4.zhimg.com/80/v2-50f9105dbb48ea862f9576e0914050e7_720w.webp)

# DDD实战

![](https://pic3.zhimg.com/80/v2-91a6800bf314a7621f9cc2f4f0f96792_720w.webp)

模块划分如下

![](https://pic4.zhimg.com/80/v2-c29ab3e03ab1630c1d71b3b31764b4c7_720w.webp)

本次我们重点完成

*   **账户模块**
*   **广告管理模块**
*   **广告下发模块**

## 战略设计

战略设计阶段： 此阶段主要是依赖于事件风暴（可理解为基于事件流程的头脑风暴），来呈现出产品的发展方向以及核心流程和场景，并文档化。

1.产品要解决的问题，以及从用户角度归纳出典型业务场景，落实文档 -----> 产品愿景、场景分析

2.找出上一步总结出的关键名词，作为各个场景的实体 -----> 领域建模：找出领域对象

3.根据上一步总结出实体，总结出之间的关系（聚合根、值对象、普通实体），划分出聚合 -----> 领域建模：定义聚合

4.以上一步归纳出的聚合为单位，根据业务场景将聚合分组，得到限界上下文（也就是所属的领域） ----->领域建模：定义界限上下文

在第 1 步落实文档后，后面的 2，3，4 领域建模阶段都要不断的参照第 1 步总结出的业务流程场景来进行拆解与合并； 产品愿景、场景分析 两个阶段是从宏观到微观的过程，而 领域建模阶段是从微观到宏观的过程，也就是自底向上的思想。整体就像是总分、分总的过程。

### 产品愿景

**产品愿景是对产品顶层价值设计，对产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。**

*   服务用户

想投广告的人。广告主以及代理商的优化师

*   提供能力

给广告主提供丰富的广告资源，实现广告的管理和投放。广告投放效果，以及**效率**。

提高交互效率。提供open-api，可以让客户通过程序化的方式管理广告。

*   定位

业界先进的一站式效果投放平台。提供RTA，DPA，OCPX等专业能力

*   优势

依托于手机厂商提供的数据能力，给广告主提供更好的投放效果。

### 场景分析

![](https://pic3.zhimg.com/80/v2-f8b2ea002bc80427f089849e25992782_720w.webp)

### 领域建模

领域建模是通过对业务和问题域进行分析，建立领域模型。

向上通过限界上下文指导微服务边界设计，向下通过聚合指导实体对象设计。

领域建模是一个收敛的过程，分三步：

第一步找出领域实体和值对象等领域对象；

第二步找出聚合根，根据实体、值对象与聚合根的依赖关系，建立聚合；

第三步根据业务及语义边界等因素，定义限界上下文。

第一步：找出实体和值对象等领域对象

根据场景分析，分析并找出发起或产生这些命令或领域事件的实体和值对象，将与实体或值对象有关的命令和事件聚集到实体。

![](https://pic1.zhimg.com/80/v2-a630cfc99567134bc5a3f84927de5d78_720w.webp)

第二步：定义聚合

定义聚合前，先找出聚合根。然后找出与聚合根紧密依赖的实体和值对象。我们发现审批意见、审批规则和请假单紧密关联，组织关系和人员紧密关联。

![](https://pic2.zhimg.com/80/v2-91d7501164b3306a52c640f719a4c7c1_720w.webp)

第三步：定义限界上下文

把整个定义为广告管理限界上下文

### 通用语言

广告业务：

中文 英文 广告计划 AdCampaign 广告组 AdGroup 广告定向 AdTargeting 广告创意 AdCreative 广告素材 AdAsset 操作日志 OperationLog 账号 Account

### 微服务拆分

理论上一个限界上下文就可以设计为一个微服务，但还需要综合考虑多种外部因素，比如：职责单一性、敏态与稳态业务分离、非功能性需求（如弹性伸缩、版本发布频率和安全等要求）、软件包大小、团队沟通效率和技术异构等非业务要素。

**可以微服务的拆分粒度大一些，但是聚合和限界上下文一定要边界清晰，后续随着某些功能逐渐变大再去拆分也会比较容易**

## 战术设计

有了战略设计阶段的结果，反而战术设计阶段相对清晰一些。

1.按照 DDD 四层模型建包，咱们这里使用COLA生成的包结构

2.确定聚合中的对象关系，定义哪些是实体，哪些是值对象，具体字段都有什么。

3.**通过战略设计阶段文档中的命令、事件来编排充血模型的领域对象，构建应用服务与领域服务**

## 详细设计

技术选型跟上面的关系不大。可以使用COLA4.0分层框架。

使用SpringCloud技术栈，以及根据业务建模选择中间件。

# 低代码平台

> 低代码开发平台（LCDP）是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。低代码开发平台（LCDP）的正式名称直到2014年6月才正式确定，整个低代码开发领域却可以追溯到更早前第四代编程语言和快速应用开发工具。

## Microsoft Platform

> 其包括 Power Apps, Power Apps Sutdio ,Power Apps Mobile, Power Platform Admin Center。

> Power BI 商业表格 Power Apps 创建app Power Pages 网页 Power Automate 自动化流程 Power Virtual Agents。 聊天机器人

> PCF（Power Apps Component Framework） 为程序员提供利用代码开发自定义组件。

> Microsoft Dataverse 存储和管理业务应用程序使用的数据

> 流程自动化。

# OPS

计算机软件管理中的基本概念以及定义性的东西

多关注最新国外行业消息和一些书籍

敏捷开发 scrum

*   个体和互动高于流程和工具
*   工作的软件高于详尽的文档
*   客户合作高于合同谈判
*   响应变化高于遵循计划

敏捷开发注重交流，交互，交付，变化。

软件工程

持续集成devops ci cd

grpc

脚手架：CLI -- Command-Line Interface 命令行界面，俗称脚手架。脚手架就是一个大概的框架，是建筑学上的一个概念。

Etl 工具

Msbuild

新技术专项什么是企业中台

但是，时间一长大家就发现了，这些系统中有一些部分大同小异，在做第二个项目的时候并不用将所有的功能重写，可以把之前项目中那些共有的模块拿出来，稍作修改就可以在新项目中应用了。这就是中台的雏形。

转动的齿轮

抽象和解耦是软件开发铁律，同样也适用于中台系统。中台系统就是将“后台”系统中那些针对技术，业务，组织的通用“模块/服务”从原来固定的项目中抽离出来，并且使之能够成为一个自治的服务提供给更多的“前台”使用。

中台分为如下几类：

业务中台：例如：客户服务，结算中心，订单中心。

技术中台：通常我们会将服务进行拆解通过微服务的方式重新组织。每个微服务都是自我治理的，通过服务注册，服务网关，服务跟踪的方式让他们形成一个整体。技术中台的划分通常分为两个维度，第一个是基础服务，这些服务针对整个系统来说相对通用，如：日志服务，安全服务等等。第二个就是业务服务，这些服务都针对每个业务模块做划分，通常这些服务会根据业务的变化或者增量进行更新或者横向扩展。

数据中台：数据的获取通常需要经过数据采集，数据清洗/过滤，数据存储，数据归档几个步骤，最后才能通过数据服务的形式展现给用户。特别是针对客户端来说，同时通过数据中台提供的服务来获取数据的。数据中台会根据不同的业务场景，生成不同的数据服务，满足客户的需要。让前端不用关心数据处理过程，只专注于“数据服务”

组织中台：相关的人员组织

关于开源如果单纯享用成功不付出是不行的。开源的模式最好是相关组织，组织内都是贡献者，非贡献者需要购买商业许可。组织成员也要定期考核，不合格者剔除。当然那种来源给所有人类的贡献者自然是伟大的，但是却也培养出一批懒人，寄生虫！

红薯，组织结构

职能型

项目型
